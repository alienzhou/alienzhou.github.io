<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  AlienZHOU's blog
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="AlienZHOU's blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">AlienZHOU's blog</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; AlienZHOU's blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>PWA</label></li>

          
            <li><a title="【PWA学习与实践】(10)使用Resource Hint提升页面加载性能与体验" href="15354508213008.html">【PWA学习与实践】(10)使用Resource Hint提升页面加载性能与体验</a></li>
          
            <li><a title="【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案" href="15288038664515.html">【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案</a></li>
          
            <li><a title="【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync" href="15288038009038.html">【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync</a></li>
          
            <li><a title="【PWA学习与实践】(7)使用Notification API来进行消息提醒" href="15288036503920.html">【PWA学习与实践】(7)使用Notification API来进行消息提醒</a></li>
          
            <li><a title="【PWA学习与实践】(6) 在Chrome中调试你的PWA" href="15288035758780.html">【PWA学习与实践】(6) 在Chrome中调试你的PWA</a></li>
          
            <li><a title="【PWA学习与实践】(5)在Web中进行服务端消息推送" href="15288030176091.html">【PWA学习与实践】(5)在Web中进行服务端消息推送</a></li>
          
            <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
          
            <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
          
            <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
          
            <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
          

      
        <li class="divider"></li>
        <li><label>React</label></li>

          
            <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
          
            <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
          

      
        <li class="divider"></li>
        <li><label>CSS</label></li>

          
            <li><a title="CSS布局学习指南[译]" href="15301745888974.html">CSS布局学习指南[译]</a></li>
          
            <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
          
            <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
          
            <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
          

      
        <li class="divider"></li>
        <li><label>Server</label></li>

          
            <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
          

      
        <li class="divider"></li>
        <li><label>Automation</label></li>

          
            <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
          

      
        <li class="divider"></li>
        <li><label>FE else</label></li>

          
            <li><a title="各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）" href="15288039493853.html">各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）</a></li>
          
            <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
          
            <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
          
            <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
          

      
        <li class="divider"></li>
        <li><label>Reading</label></li>

          
            <li><a title="推荐阅读 2018.08" href="15333560595579.html">推荐阅读 2018.08</a></li>
          
            <li><a title="推荐阅读 2018.07" href="15307688152882.html">推荐阅读 2018.07</a></li>
          
            <li><a title="推荐阅读 2018.06" href="15288017709756.html">推荐阅读 2018.06</a></li>
          
            <li><a title="推荐阅读 2018.05" href="15287963471356.html">推荐阅读 2018.05</a></li>
          
            <li><a title="推荐阅读 2018.04" href="15283399559020.html">推荐阅读 2018.04</a></li>
          
            <li><a title="推荐阅读 2018.03" href="15282529256902.html">推荐阅读 2018.03</a></li>
          

      
        <li class="divider"></li>
        <li><label>Performace</label></li>

          
            <li><a title="【性能优化实践】优化打包策略提升页面加载速度" href="15288037747207.html">【性能优化实践】优化打包策略提升页面加载速度</a></li>
          

      
        <li class="divider"></li>
        <li><label>webpack</label></li>

          
            <li><a title="【webpack进阶】使用babel避免webpack编译运行时模块依赖" href="15354509456422.html">【webpack进阶】使用babel避免webpack编译运行时模块依赖</a></li>
          
            <li><a title="【webpack进阶】前端运行时的模块化设计与实现" href="15353386669734.html">【webpack进阶】前端运行时的模块化设计与实现</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>PWA</span></li>
                        
                          <li><a title="【PWA学习与实践】(10)使用Resource Hint提升页面加载性能与体验" href="15354508213008.html">【PWA学习与实践】(10)使用Resource Hint提升页面加载性能与体验</a></li>
                        
                          <li><a title="【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案" href="15288038664515.html">【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案</a></li>
                        
                          <li><a title="【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync" href="15288038009038.html">【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync</a></li>
                        
                          <li><a title="【PWA学习与实践】(7)使用Notification API来进行消息提醒" href="15288036503920.html">【PWA学习与实践】(7)使用Notification API来进行消息提醒</a></li>
                        
                          <li><a title="【PWA学习与实践】(6) 在Chrome中调试你的PWA" href="15288035758780.html">【PWA学习与实践】(6) 在Chrome中调试你的PWA</a></li>
                        
                          <li><a title="【PWA学习与实践】(5)在Web中进行服务端消息推送" href="15288030176091.html">【PWA学习与实践】(5)在Web中进行服务端消息推送</a></li>
                        
                          <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
                        
                          <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
                        
                          <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
                        
                          <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
                        

                    
                      <li class="side-title"><span>React</span></li>
                        
                          <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
                        
                          <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
                        

                    
                      <li class="side-title"><span>CSS</span></li>
                        
                          <li><a title="CSS布局学习指南[译]" href="15301745888974.html">CSS布局学习指南[译]</a></li>
                        
                          <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
                        
                          <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
                        
                          <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
                        

                    
                      <li class="side-title"><span>Server</span></li>
                        
                          <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
                        

                    
                      <li class="side-title"><span>Automation</span></li>
                        
                          <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
                        

                    
                      <li class="side-title"><span>FE else</span></li>
                        
                          <li><a title="各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）" href="15288039493853.html">各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）</a></li>
                        
                          <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
                        
                          <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
                        
                          <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
                        

                    
                      <li class="side-title"><span>Reading</span></li>
                        
                          <li><a title="推荐阅读 2018.08" href="15333560595579.html">推荐阅读 2018.08</a></li>
                        
                          <li><a title="推荐阅读 2018.07" href="15307688152882.html">推荐阅读 2018.07</a></li>
                        
                          <li><a title="推荐阅读 2018.06" href="15288017709756.html">推荐阅读 2018.06</a></li>
                        
                          <li><a title="推荐阅读 2018.05" href="15287963471356.html">推荐阅读 2018.05</a></li>
                        
                          <li><a title="推荐阅读 2018.04" href="15283399559020.html">推荐阅读 2018.04</a></li>
                        
                          <li><a title="推荐阅读 2018.03" href="15282529256902.html">推荐阅读 2018.03</a></li>
                        

                    
                      <li class="side-title"><span>Performace</span></li>
                        
                          <li><a title="【性能优化实践】优化打包策略提升页面加载速度" href="15288037747207.html">【性能优化实践】优化打包策略提升页面加载速度</a></li>
                        

                    
                      <li class="side-title"><span>webpack</span></li>
                        
                          <li><a title="【webpack进阶】使用babel避免webpack编译运行时模块依赖" href="15354509456422.html">【webpack进阶】使用babel避免webpack编译运行时模块依赖</a></li>
                        
                          <li><a title="【webpack进阶】前端运行时的模块化设计与实现" href="15353386669734.html">【webpack进阶】前端运行时的模块化设计与实现</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 


	
		<div class="markdown-body">
		<h1>【webpack进阶】使用babel避免webpack编译运行时模块依赖</h1>

		<h2 id="toc_0">引言</h2>

<p>babel是一个非常强大的工具，作用远不止我们平时的ES6 -&gt; ES5语法转换这么单一。在前端进阶的道路上，了解与学习babel及其灵活的插件模式将会为前端赋予更多的可能性。</p>

<p>本文就是运用babel，通过编写babel插件解决了一个实际项目中的问题。</p>

<blockquote>
<p>本文相关代码已托管至github: <a href="https://github.com/alienzhou/babel-plugin-import-customized-require">babel-plugin-import-customized-require</a></p>
</blockquote>

<h2 id="toc_1">1. 遇到的问题</h2>

<p>最近在项目中遇到这样一个问题：我们知道，使用webpack作为构建工具是会默认自动帮我们进行依赖构建；但是在项目代码中，有一部分的依赖是运行时依赖/非编译期依赖（可以理解为像requirejs、seajs那样的纯前端模块化），对于这种依赖不做处理会导致webpack编译出错。</p>

<p>为什么需要非编译期依赖呢？例如，在当前的业务模块（一个独立的webpack代码仓库）里，我依赖了一个公共业务模块的打点代码</p>

<pre><code class="language-javascript">// 这是home业务模块代码
// 依赖了common业务模块的代码
import log from &#39;common:util/log.js&#39;

log(&#39;act-1&#39;);
</code></pre>

<p>然而，可能是由于技术栈不统一，或是因为common业务代码遗留问题无法重构，或者仅仅是为了业务模块的分治……总之，无法在webpack编译期解决这部分模块依赖，而是需要放在前端运行时框架解决。</p>

<p>为了解决webpack编译期无法解析这种模块依赖的问题，可以给这种非编译期依赖引入新的语法，例如下面这样：</p>

<pre><code class="language-javascript">// __my_require__是我们自定义的前端require方法
var log = __my_require__(&#39;common:util/log.js&#39;)

log(&#39;act-1&#39;);
</code></pre>

<p>但这样就导致了我们代码形式的分裂，拥抱规范让我们希望还是能够用ESM的标准语法来一视同仁。</p>

<p>我们还是希望能像下面这样写代码：</p>

<pre><code class="language-javascript">// 标准的ESM语法
import * as log from &#39;common:util/log.js&#39;;

log(&#39;act-1&#39;);
</code></pre>

<p>此外，也可以考虑使用webpack提供了externals配置来避免某些模块被webpack打包。然而，一个重要的问题是，在已有的common代码中有一套前端模块化语法，要将webpack编译出来的代码与已有模式融合存在一些问题。因此该方式也存在不足。</p>

<p>针对上面的描述，总结来说，我们的目的就是：</p>

<ul>
<li>能够在代码中使用ESM语法，来进行非编译期分析的模块引用</li>
<li>由于webpack会尝试打包该依赖，需要不会在编译期出错</li>
</ul>

<h2 id="toc_2">2. 解决思路</h2>

<p>基于上面的目标，首先，我们需要有一种方式能够标识不需要编译的运行期依赖。例如<code>util/record</code>这个模块，如果是运行时依赖，可以参考标准语法，为模块名添加标识：<code>runtime:util/record</code>。效果如下：</p>

<pre><code class="language-javascript">// 下面这两行是正常的编译期依赖
import React from &#39;react&#39;;
import Nav from &#39;./component/nav&#39;;

// 下面这两个模块，我们不希望webpack在编译期进行处理
import record from &#39;runtime:util/record&#39;;
import {Banner, List} from &#39;runtime:ui/layout/component&#39;;
</code></pre>

<p>其次，虽然标识已经可以让开发人员知道代码里哪些模块是webpack需要打包的依赖，哪些是非编译期依赖；但webpack不知道，它只会拿到模块源码，分析import语法拿到依赖，然后尝试加载依赖模块。但这时webpack傻眼了，因为像<code>runtime:util/record</code>这样的模块是运行时依赖，编译期找不到该模块。那么，就需要通过一种方式，让webpack“看不见”非编译期的依赖。</p>

<p>最后，拿到非编译期依赖，由于浏览器现在还不支持ESM的import语法，因此需要将它变为在前端运行时我们自定义的模块依赖语法。</p>

<pre><code class="language-flow">st=&gt;start: 开始
op1=&gt;operation: 读取源码
op2=&gt;operation: 获取模块导入语法
op3=&gt;operation: 语法转换
cond=&gt;condition: 是否非编译期依赖
e=&gt;end: 结束
st-&gt;op1-&gt;op2-&gt;cond
cond(no)-&gt;e
cond(yes)-&gt;op3-&gt;e
</code></pre>

<h2 id="toc_3">3. 使用babel对源码进行分析</h2>

<h3 id="toc_4">3.1. babel相关工具介绍</h3>

<blockquote>
<p>对babel以及插件机制不太了解的同学，可以先看这一部分做一个简单的了解。</p>
</blockquote>

<p>babel是一个强大的javascript compiler，可以将源码通过词法分析与语法分析转换为AST（抽象语法树），通过对AST进行转换，可以修改源码，最后再将修改后的AST转换会目标代码。</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/8/17/1654852a672a4d8e?w=2004&amp;h=362&amp;f=png&amp;s=107940" alt=""/></p>

<p>由于篇幅限制，本文不会对compiler或者AST进行过多介绍，但是如果你学过编译原理，那么对词法分析、语法分析、token、AST应该都不会陌生。即使没了解过也没有关系，你可以粗略的理解为：babel是一个compiler，它可以将javascript源码转化为一种特殊的数据结构，这种数据结构就是树，也就是AST，它是一种能够很好表示源码的结构。babel的AST是基于<a href="https://github.com/estree/estree">ESTree</a>的。</p>

<p>例如，<code>var alienzhou = &#39;happy&#39;</code>这条语句，经过babel处理后它的AST大概是下面这样的</p>

<pre><code class="language-javascript">{
    type: &#39;VariableDeclaration&#39;,
    kind: &#39;var&#39;,
    // ...其他属性
    decolarations: [{
        type: &#39;VariableDeclarator&#39;,
        id: {
            type: &#39;Identifier&#39;,
            name: &#39;alienzhou&#39;,
            // ...其他属性
        },
        init: {
            type: &#39;StringLiteral&#39;,
            value: &#39;happy&#39;,
            // ...其他属性
        }
    }],
}
</code></pre>

<p>这部分AST node表示，这是一条变量声明的语句，使用<code>var</code>关键字，其中id和init属性又是两个AST node，分别是名称为alienzhou的标识符（Identifier）和值为happy的字符串字面量（StringLiteral）。</p>

<p>这里，简单介绍一些如何使用babel及其提供的一些库来进行AST的分析和修改。生成AST可以通过<code>babel-core</code>里的方法，例如：</p>

<pre><code class="language-javascript">const babel = require(&#39;babel-core&#39;);
const {ast} = babel.transform(`var alienzhou = &#39;happy&#39;`);
</code></pre>

<p>然后遍历AST，找到特定的节点进行修改即可。babel也为我们提供了traverse方法来遍历AST：</p>

<pre><code class="language-javascript">const traverse = require(&#39;babel-traverse&#39;).default;
</code></pre>

<p>在babel中访问AST node使用的是<a href="https://en.wikipedia.org/wiki/Visitor_pattern">vistor模式</a>，可以像下面这样指定AST node type来访问所需的AST node：</p>

<pre><code class="language-javascript">traverse(ast, {
    StringLiteral(path) {
        console.log(path.node.value)
        // ...
    }
})
</code></pre>

<p>这样就可以得到所有的字符串字面量，当然你也可以替换这个节点的内容：</p>

<pre><code class="language-javascript">let visitor = {
    StringLiteral(path) {
        console.log(path.node.value)
        path.replaceWith(
            t.stringLiteral(&#39;excited&#39;);
        )
    }
};
traverse(ast, visitor);
</code></pre>

<blockquote>
<p>注意，AST是一个mutable对象，所有的节点操作都会在原AST上进行修改。</p>
</blockquote>

<p>这篇文章不会详细介绍babel-core、babel-traverse的API，而是帮助没有接触过的朋友快速理解它们，具体的使用方式可以参考相关文档。</p>

<p>由于大部分的webpack项目都会在loader中使用babel，因此只需要提供一个babel的插件来处理非编译期依赖语法即可。而babel插件其实就是导出一个方法，该方法会返回我们上面提到的visitor对象。</p>

<p>那么接下来我们专注于visitor的编写即可。</p>

<h3 id="toc_5">3.2 编写一个babel插件来解决非编译期依赖</h3>

<p>ESM的import语法在AST node type中是<a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md#importdeclaration">ImportDeclaration</a>：</p>

<pre><code class="language-javascript">export default function () {
    return {
        ImportDeclaration: {
            enter(path) {
                // ...
            }
            exit(path) {
                let source = path.node.source;
                if (t.isStringLiteral(source) &amp;&amp; /^runtime:/.test(source.value)) {
                    // ...
                }
            }
        }
    }
}
</code></pre>

<p>在enter方法里，需要收集ImportDeclaration语法的相关信息；在exit方法里，判断当前ImportDeclaration是否为非编译期依赖，如果是则进行语法转换。</p>

<p>收集ImportDeclaration语法相关信息需要注意，对于不同的import specifier类型，需要不同的分析方式，下面列举了这五种import：</p>

<pre><code class="language-javascript">import util from &#39;runtime:util&#39;;
import * as util from &#39;runtime:util&#39;;
import {util} from &#39;runtime:util&#39;;
import {util as u} from &#39;runtime:util&#39;;
import &#39;runtime:util&#39;;
</code></pre>

<p>对应了三类specifier：</p>

<ul>
<li>ImportSpecifier：<code>import {util} from &#39;runtime:util&#39;</code>,<code>import {util as u} from &#39;runtime:util&#39;;</code></li>
<li>ImportDefaultSpecifier：<code>import util from &#39;runtime:util&#39;</code></li>
<li>ImportNamespaceSpecifier：<code>import * as util from &#39;runtime:util&#39;</code></li>
</ul>

<blockquote>
<p><code>import &#39;runtime:util&#39;</code>中没有specifier</p>
</blockquote>

<p>可以在ImportDeclaration的基础上，对子节点进行traverse，这里新建了一个visitor用来访问Specifier，针对不同语法进行收集：</p>

<pre><code class="language-javascript">const specifierVisitor = {
    ImportNamespaceSpecifier(_path) {
        let data = {
            type: &#39;NAMESPACE&#39;,
            local: _path.node.local.name
        };

        this.specifiers.push(data);
    },

    ImportSpecifier(_path) {
        let data = {
            type: &#39;COMMON&#39;,
            local: _path.node.local.name,
            imported: _path.node.imported ? _path.node.imported.name : null
        };

        this.specifiers.push(data);
    },

    ImportDefaultSpecifier(_path) {
        let data = {
            type: &#39;DEFAULT&#39;,
            local: _path.node.local.name
        };

        this.specifiers.push(data);
    }
}
</code></pre>

<p>在ImportDeclaration中使用specifierVisitor进行遍历：</p>

<pre><code class="language-javascript">export default function () {
    // store the specifiers in one importDeclaration
    let specifiers = [];
    return {
        ImportDeclaration: {
            enter(path) {
                path.traverse(specifierVisitor, { specifiers });
            }
            exit(path) {
                let source = path.node.source;
                if (t.isStringLiteral(source) &amp;&amp; /^runtime:/.test(source.value)) {
                    // ...
                }
            }
        }
    }
}
</code></pre>

<p>到目前为止，我们在进入ImportDeclaration节点时，收集了import语句相关信息，在退出节点时，通过判断可以知道目前节点是否是非编译期依赖。因此，如果是非编译期依赖，只需要根据收集到的信息替换节点语法即可。</p>

<p>生成新节点可以使用babel-types。不过推荐使用babel-template，会令代码更简便与清晰。下面这个方法，会根据不同的import信息，生成不同的运行时代码，其中假定__my_require__方法就是自定义的前端模块require方法。</p>

<pre><code class="language-javascript">const template = require(&#39;babel-template&#39;);

function constructRequireModule({
    local,
    type,
    imported,
    moduleName
}) {

    /* using template instead of origin type functions */
    const namespaceTemplate = template(`
        var LOCAL = __my_require__(MODULE_NAME);
    `);

    const commonTemplate = template(`
        var LOCAL = __my_require__(MODULE_NAME)[IMPORTED];
    `);

    const defaultTemplate = template(`
        var LOCAL = __my_require__(MODULE_NAME)[&#39;default&#39;];
    `);

    const sideTemplate = template(`
        __my_require__(MODULE_NAME);
    `);
    /* ********************************************** */

    let declaration;
    switch (type) {
        case &#39;NAMESPACE&#39;:
            declaration = namespaceTemplate({
                LOCAL: t.identifier(local),
                MODULE_NAME: t.stringLiteral(moduleName)
            });
            break;

        case &#39;COMMON&#39;:
            imported = imported || local;
            declaration = commonTemplate({
                LOCAL: t.identifier(local),
                MODULE_NAME: t.stringLiteral(moduleName),
                IMPORTED: t.stringLiteral(imported)
            });
            break;

        case &#39;DEFAULT&#39;:
            declaration = defaultTemplate({
                LOCAL: t.identifier(local),
                MODULE_NAME: t.stringLiteral(moduleName)
            });
            break;

        case &#39;SIDE&#39;:
            declaration = sideTemplate({
                MODULE_NAME: t.stringLiteral(moduleName)
            })

        default:
            break;
    }

    return declaration;
}
</code></pre>

<p>最后整合到一开始的visitor中：</p>

<pre><code class="language-javascript">export default function () {
    // store the specifiers in one importDeclaration
    let specifiers = [];
    return {
        ImportDeclaration: {
            enter(path) {
                path.traverse(specifierVisitor, { specifiers });
            }
            exit(path) {
                let source = path.node.source;
                let moduleName = path.node.source.value;
                if (t.isStringLiteral(source) &amp;&amp; /^runtime:/.test(source.value)) {
                    let nodes;
                    if (specifiers.length === 0) {
                        nodes = constructRequireModule({
                            moduleName,
                            type: &#39;SIDE&#39;
                        });
                        nodes = [nodes]
                    }
                    else {
                        nodes = specifiers.map(constructRequireModule);
                    }
                    path.replaceWithMultiple(nodes);
                }
                specifiers = [];
            }
        }
    }
}
</code></pre>

<p>那么，对于一段<code>import util from &#39;runtime:util&#39;</code>的源码，在该babel插件修改后变为了<code>var util = require(&#39;runtime:util&#39;)[&#39;default&#39;]</code>，该代码也会被webpack直接输出。</p>

<p>这样，通过babel插件，我们就完成了文章最一开始的目标。</p>

<h2 id="toc_6">4. 处理dynamic import</h2>

<p>细心的读者肯定会发现了，我们在上面只解决了静态import的问题，那么像下面这样的动态import不是仍然会有以上的问题么？</p>

<pre><code class="language-javascript">import(&#39;runtime:util&#39;).then(u =&gt; {
    u.record(1);
});
</code></pre>

<p>是的，仍然会有问题。因此，进一步我们还需要处理动态import的语法。要做的就是在visitor中添加一个新的node type：</p>

<pre><code class="language-javascript">{
    Import: {
        enter(path) {
            let callNode = path.parentPath.node;
            let nameNode = callNode.arguments &amp;&amp; callNode.arguments[0] ? callNode.arguments[0] : null;

            if (t.isCallExpression(callNode)
                &amp;&amp; t.isStringLiteral(nameNode)
                &amp;&amp; /^runtime:/.test(nameNode.value)
            ) {
                let args = callNode.arguments;
                path.parentPath.replaceWith(
                    t.callExpression(
                        t.memberExpression(
                            t.identifier(&#39;__my_require__&#39;), t.identifier(&#39;async&#39;), false),
                            args
                ));
            }
        }
    }
}
</code></pre>

<p>这时，上面的动态import代码就会被替换为：</p>

<pre><code class="language-javascript">__my_require__.async(&#39;runtime:util&#39;).then(u =&gt; {
    u.record(1);
});
</code></pre>

<p>非常方便吧。</p>

<h2 id="toc_7">5. 写在最后</h2>

<blockquote>
<p>本文相关代码已托管至github: <a href="https://github.com/alienzhou/babel-plugin-import-customized-require">babel-plugin-import-customized-require</a></p>
</blockquote>

<p>本文是从一个关于webpack编译期的需求出发，应用babel来使代码中部分模块依赖不在webpack编译期进行处理。其实从中可以看出，babel给我们赋予了极大的可能性。</p>

<p>文中解决的问题只是一个小需求，也许你会有更不错的解决方案；然而这里更多的是展示了babel的灵活、强大，它给前端带来的更多的空间与可能性，在许多衍生的领域也都能发现它的身影。希望本文能成为一个引子，为你拓展解决问题的另一条思路。</p>

<h2 id="toc_8">参考资料</h2>

<ul>
<li><a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md">Babel AST spec</a></li>
<li><a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a></li>
<li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md">Babel Plugin Handbook</a></li>
<li><a href="http://astexplorer.net/">AST Explorer</a></li>
</ul>


		</div>
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

 
	

  
  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
