<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Server - AlienZHOU's blog
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="AlienZHOU's blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">AlienZHOU's blog</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; AlienZHOU's blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>PWA</label></li>

          
            <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
          
            <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
          
            <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
          
            <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
          

      
        <li class="divider"></li>
        <li><label>React</label></li>

          
            <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
          
            <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
          

      
        <li class="divider"></li>
        <li><label>CSS</label></li>

          
            <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
          
            <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
          
            <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
          

      
        <li class="divider"></li>
        <li><label>Server</label></li>

          
            <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
          

      
        <li class="divider"></li>
        <li><label>Automation</label></li>

          
            <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
          

      
        <li class="divider"></li>
        <li><label>FE else</label></li>

          
            <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
          
            <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
          
            <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>PWA</span></li>
                        
                          <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
                        
                          <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
                        
                          <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
                        
                          <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
                        

                    
                      <li class="side-title"><span>React</span></li>
                        
                          <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
                        
                          <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
                        

                    
                      <li class="side-title"><span>CSS</span></li>
                        
                          <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
                        
                          <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
                        
                          <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
                        

                    
                      <li class="side-title"><span>Server</span></li>
                        
                          <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
                        

                    
                      <li class="side-title"><span>Automation</span></li>
                        
                          <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
                        

                    
                      <li class="side-title"><span>FE else</span></li>
                        
                          <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
                        
                          <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
                        
                          <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 


	
		<div class="markdown-body">
		<h1>【MongoDB高可用】复制集Replica Set使用简介</h1>

		<h2 id="toc_0">MongoDB高可用</h2>

<p>对于MongoDB，可以支持使用单机模式提供服务，但是在实际的生产环境中，单机模式将面临很大的风险，一旦这个数据库服务出现问题，就会导致线上的服务出现错误甚至崩溃。因此，在实际生产环境下，需要对MongoDB做相应的主备处理，提高数据库服务的可用性。</p>

<p>对于提高可用性，一些博文里提到了使用<a href="https://docs.mongodb.com/manual/core/master-slave/">主从模式（master-slaver）</a>。</p>

<blockquote>
<p>WARNING:<br/>
Deprecated since version 3.2: MongoDB 3.2 deprecates the use of master-slave replication for components of sharded clusters.</p>
</blockquote>

<p>主从模式是高可用的一种方案。<strong>然而从上面这段警告中可以知道，在高版本的MongoDB（3.2以上）中，官方已经不推荐使用主从模式，取而代之的，是使用复制集（Replica Set）的方式做主备处理。</strong></p>

<blockquote>
<p>IMPORTANT:<br/>
Replica sets replace master-slave replication for most use cases. If possible, use replica sets rather than master-slave replication for all new production deployments. This documentation remains to support legacy deployments and for archival purposes only.</p>
</blockquote>

<p>因此，本文将介绍如何将已有的单机MongoDB数据库拓展为主备模式的复制集，以提高可用性。</p>

<h2 id="toc_1">复制集 Replica Set</h2>

<p>在复制集中，有且只有一个主节点(primary)，可以包含一个或多个从节点(secondary)，主从节点直接会通过心跳检测来确定节点是否健康或存活。所有的读写操作都是在主节点上进行的，如果要实现读写分离，需要进行相应的处理，这个最后会说。从节点会根据oplog（也就是操作日志）来复制主节点的数据。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/6476654-c7ddd05244104156.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MongoDB复制集"/></p>

<p>除了主从节点外，MongoDB的复制集中还存在着一种叫仲裁者(Arbiter)的角色。一个仲裁者节点是比较轻量级的，因为它不会去复制主库的数据，因此也就不会成为主节点；但是，它的作用是在投票选举阶段——当主节点故障时，仲裁者可以进行投票。一般来说，不建议一个复制集中包含超过一个仲裁者。</p>

<p>当主节点突然故障后，MongoDB有自己的机制，会自动切换，通过选举，在从节点中选出一个节点作为新的主节点。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/6476654-b6c6fbf9d5b79189.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MongoDB复制集故障处理"/></p>

<h2 id="toc_2">如何使用复制集</h2>

<p>首先，需要在MongoDB实例的启动参数中加入replSet，指定复制集的名称。</p>

<pre><code class="language-bash">mongod --port 8017 --dbpath /home/work/data/db1 --replSet rstest
</code></pre>

<p>对于已有的单机实例，也可以加入该参数并进行重启。此外，我们还需要另外启动两个MongoDB实例作为从节点，注意replSet参数指定的名称需要相同。</p>

<pre><code class="language-bash">mongod --port 8016 --dbpath /home/work/data/db2 --replSet rstest
mongod --port 8015 --dbpath /home/work/data/db2 --replSet rstest
</code></pre>

<p>然后，需要通过mongo命令连接MongoDB服务，进入主节点进行初始化。</p>

<pre><code class="language-bash">mongo 127.0.0.1:8017
</code></pre>

<pre><code class="language-javascript">rs.initiate({
  _id:&quot;rstest&quot;, // replSet指定的名称
  members:[{
    _id:0,
    host:&quot;127.0.0.1:8017&quot; // 主节点ip与端口
  }]
})
</code></pre>

<p>需要注意的是，如果是将已有单机拓展为复制集，要在连接原单机的实例并在其中运行使其作为主节点。</p>

<p>最后，再将其他两个从节点加入到该复制集中。</p>

<pre><code class="language-javascript">rs.add(&quot;127.0.0.1:8016&quot;)
rs.add(&quot;127.0.0.1:8015&quot;)
</code></pre>

<p>通过<code>rs.status()</code>查看效果，可以看到<code>rstest</code>这个复制集中已经有了三个节点，<code>stateStr</code>指明了节点的类型，<code>health</code>为1表明该节点是健康的。</p>

<pre><code class="language-javascript">{
    &quot;set&quot; : &quot;rstest&quot;,
    &quot;date&quot; : ISODate(&quot;2017-10-31T13:04:16.704Z&quot;),
    &quot;myState&quot; : 1,
    &quot;members&quot; : [
        {
            &quot;_id&quot; : 0,
            &quot;name&quot; : &quot;127.0.0.1:8017&quot;,
            &quot;health&quot; : 1,
            &quot;state&quot; : 1,
            &quot;stateStr&quot; : &quot;PRIMARY&quot;, // 节点的类型，主节点
            &quot;uptime&quot; : 1508,
            &quot;optime&quot; : Timestamp(1509455043, 1),
            &quot;optimeDate&quot; : ISODate(&quot;2017-10-31T13:04:03Z&quot;),
            &quot;electionTime&quot; : Timestamp(1509454568, 2),
            &quot;electionDate&quot; : ISODate(&quot;2017-10-31T12:56:08Z&quot;),
            &quot;configVersion&quot; : 3,
            &quot;self&quot; : true
        },
        {
            &quot;_id&quot; : 1,
            &quot;name&quot; : &quot;127.0.0.1:8016&quot;,
            &quot;health&quot; : 1,
            &quot;state&quot; : 2,
            &quot;stateStr&quot; : &quot;SECONDARY&quot;,
            &quot;uptime&quot; : 25,
            &quot;optime&quot; : Timestamp(1509455043, 1),
            &quot;optimeDate&quot; : ISODate(&quot;2017-10-31T13:04:03Z&quot;),
            &quot;lastHeartbeat&quot; : ISODate(&quot;2017-10-31T13:04:15.657Z&quot;),
            &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-10-31T13:04:15.108Z&quot;),
            &quot;pingMs&quot; : 0,
            &quot;syncingTo&quot; : &quot;127.0.0.1:8017&quot;,
            &quot;configVersion&quot; : 3
        },
        {
            &quot;_id&quot; : 2,
            &quot;name&quot; : &quot;127.0.0.1:8015&quot;,
            &quot;health&quot; : 1,
            &quot;state&quot; : 2,
            &quot;stateStr&quot; : &quot;SECONDARY&quot;,
            &quot;uptime&quot; : 13,
            &quot;optime&quot; : Timestamp(1509455043, 1),
            &quot;optimeDate&quot; : ISODate(&quot;2017-10-31T13:04:03Z&quot;),
            &quot;lastHeartbeat&quot; : ISODate(&quot;2017-10-31T13:04:15.657Z&quot;),
            &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-10-31T13:04:15.661Z&quot;),
            &quot;pingMs&quot; : 0,
            &quot;configVersion&quot; : 3
        }
    ],
    &quot;ok&quot; : 1
}
</code></pre>

<h2 id="toc_3">连接复制集</h2>

<p>由于复制集中的切换机制，在主节点故障的情况下，集群内其他从节点会通过投票方式产生新的主节点，因此，不能像单机情况下那样，直接连接主节点；否则在MongoDB自动切换主节点时，数据库访问就会出问题。因此连接复制集需要特定的连接方式。</p>

<p>在MongoDB的连接字符串(connection url)中可以进行指定。</p>

<pre><code>mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]
</code></pre>

<p>其中可以指定多个host:port，用英文逗号连接，并在最后的option中支持replicaSet参数，用于指定连接的复制集。例如：</p>

<pre><code>mongodb://127.0.0.1:8017,127.0.0.1:8016,127.0.0.1:8015/books?replicaSet=rstest
</code></pre>

<p>这样就可以连接上复制集中的books这个数据库。</p>

<h2 id="toc_4">总结</h2>

<p>MongoDB复制集的故障机制切换是它自身来保障，在部署好上面一系列的服务后，我们可以测试一下当主节点故障时，集群中的节点状态与服务可用性。通过kill主节点MongoDB进程，使用<code>rs.status()</code>可以发现，其中一个从节点已经升级为了主节点（这部分在从节点的日志中也有体现）。此外，数据查询依然可以进行，不会因为主节点的宕机而导致数据服务不可用。</p>


		</div>
	

  
  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
