<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  浏览器同源策略与ajax跨域方法汇总 - AlienZHOU's blog
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="AlienZHOU's blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">AlienZHOU's blog</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; AlienZHOU's blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>PWA</label></li>

          
            <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
          
            <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
          
            <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
          
            <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
          

      
        <li class="divider"></li>
        <li><label>React</label></li>

          
            <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
          
            <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
          

      
        <li class="divider"></li>
        <li><label>CSS</label></li>

          
            <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
          
            <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
          
            <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
          

      
        <li class="divider"></li>
        <li><label>Server</label></li>

          
            <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
          

      
        <li class="divider"></li>
        <li><label>Automation</label></li>

          
            <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
          

      
        <li class="divider"></li>
        <li><label>FE else</label></li>

          
            <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
          
            <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
          
            <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>PWA</span></li>
                        
                          <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
                        
                          <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
                        
                          <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
                        
                          <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
                        

                    
                      <li class="side-title"><span>React</span></li>
                        
                          <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
                        
                          <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
                        

                    
                      <li class="side-title"><span>CSS</span></li>
                        
                          <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
                        
                          <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
                        
                          <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
                        

                    
                      <li class="side-title"><span>Server</span></li>
                        
                          <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
                        

                    
                      <li class="side-title"><span>Automation</span></li>
                        
                          <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
                        

                    
                      <li class="side-title"><span>FE else</span></li>
                        
                          <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
                        
                          <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
                        
                          <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>浏览器同源策略与ajax跨域方法汇总</h1>

<blockquote>
<p>本文先简要介绍前端开发中的浏览器同源政策；然后在跨域问题中，具体介绍跨域ajax请求的应用场景与实现方案。</p>
</blockquote>

<h2 id="toc_0">什么是同源策略</h2>

<p>如果你进行过前端开发，肯定或多或少会听说过、接触过所谓的同源策略。那么什么是同源策略呢？</p>

<p>要了解同源策略，首先得理解“源”。在这个语境下，源(origin)其实就是指的URL。所以，我们需要先理解URL的组成。看看这个URL：<br/>
 <a href="http://www.jianshu.com/p/bc7b8d542dcd">http://www.jianshu.com/p/bc7b8d542dcd</a></p>

<p>我们可以将它拆解为下面几个部分协议、域名和路径：</p>

<pre><code class="language-javascript">http       :// www.jianshu.com    /p/bc7b8d542dcd
${protocol}:// ${hostname}         ${pathname}
</code></pre>

<p>而对于一个更为完整的URL<code>http://www.jianshu.com:80/p/bc7b8d542dcd#sample?query=text</code></p>

<table>
<thead>
<tr>
<th>protocol</th>
<th>host</th>
<th>port</th>
<th>pathname</th>
<th>hash</th>
<th>query string</th>
</tr>
</thead>

<tbody>
<tr>
<td>http</td>
<td><a href="http://www.jianshu.com">www.jianshu.com</a></td>
<td>80</td>
<td>/p/bc7b8d542dcd</td>
<td>sample</td>
<td>query=text</td>
</tr>
<tr>
<td><code>location.protocol</code></td>
<td><code>location.host</code></td>
<td><code>location.port</code></td>
<td><code>location.pathname</code></td>
<td><code>location.hash</code></td>
<td><code>location.search</code></td>
</tr>
</tbody>
</table>

<p>而同源就是指URL中<code>protocol</code>协议、<code>host</code>域名、<code>port</code>端口这三个部分相同。</p>

<p>下表是各个URL相对于<a href="http://www.jianshu.com/p/bc7b8d542dcd%E7%9A%84%E5%90%8C%E6%BA%90%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C">http://www.jianshu.com/p/bc7b8d542dcd的同源检测结果</a></p>

<table>
<thead>
<tr>
<th>URL</th>
<th>是否同源</th>
<th>非同源原因</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>http://www.jianshu.com/p/0b2acb50f321</code></td>
<td>是</td>
<td></td>
</tr>
<tr>
<td><code>https://www.jianshu.com/p/0b2acb50f321</code></td>
<td>否</td>
<td>不同协议</td>
</tr>
<tr>
<td><code>http://www.jianshu.com:8080/p/0b2acb50f321</code></td>
<td>否</td>
<td>不同端口</td>
</tr>
<tr>
<td><code>http://www.jianshu2.com/p/0b2acb50f321</code></td>
<td>否</td>
<td>不同域名</td>
</tr>
</tbody>
</table>

<p>因此，简单来说，同源策略就是浏览器出于网站安全性的考虑，限制不同源之间的资源相互访问的一种政策。以下操作具有同源策略的限制：</p>

<ul>
<li>AJAX 请求不能发送。</li>
<li>无法获取DOM元素并进行操作。</li>
<li>无法读取Cookie、LocalStorage 和 IndexDB 。</li>
</ul>

<p>而本文就会针对<strong>跨域AJAX</strong>场景及其各种常见解决方案进行相关介绍。</p>

<p>值得一提的是，有些请求是不受到跨域限制。例如：WebSocket，script、img、iframe、video、audio标签的<code>src</code>属性等。</p>

<h2 id="toc_1">为什么实际开发中会有跨域ajax请求</h2>

<p>根据上文的内容我们可以知道，由于浏览器同源政策的影响，跨域的ajax请求是不被允许。那么在实际的开发、应用中，是否有跨域ajax的场景呢？</p>

<p>答案是肯定的。</p>

<p>那么有哪些场景会有跨域ajax的需求呢？</p>

<ol>
<li><p>当你调用一个现有的API或公开API：想象一下，你接到了一个新需求，需要在当前开发的新闻详细页<code>http://www.yournews.com/p/123</code>展示该新闻的相关推荐。令人欣慰的是，推荐的接口已经在你们公司的其他产品线里实现了，你只需要给该接口一个<code>query</code>即可：<code>http://www.mynews.com/recommend?query=123</code>。然而问题来了——你发起了一个跨域请求。</p></li>
<li><p>前后端分离的开发模式下，在本地进行接口联调时：也许在你的项目里，你想尝试前后端分离的开发模式。你在本地开发时，mock了一些假数据来帮助自己本地开发。而有一天，你希望在本地和后端同学进行联调。此时，后端rd的接口地址和你发生了跨域问题。这阻止了你们的联调，你只能继续使用你mock的假数据。</p></li>
</ol>

<p>上面只是列举了存在跨域的两个最为常见的场景，这足以说明跨域请求在实际开发中确实经常出现。</p>

<h2 id="toc_2">跨域的一些方案</h2>

<p>了解了上面的内容后，下面就来介绍一下在实践中常用的三种ajax跨域方案。这部分的实例代码可以在这里看到：<a href="https://github.com/alienzhou/cross-domain-demo">cross-domain-demo</a></p>

<p>假设这样一个跨域场景：目前有两个项目</p>

<ul>
<li><strong>myweb</strong>，这个就是我们目前开发的项目，是一个独立的站点。</li>
<li><strong>thirdparty</strong>，表示我们需要调用到的第三方（third-party）后端服务，myweb项目就是需要调用它的接口。</li>
</ul>

<p>为了简化不必要的代码编写过程，示例使用<code>express-generator</code>来快速生成myweb与thirdparty这两个应用，其中thirdparty我们只需要用到后端接口部分。</p>

<pre><code>npm install express-generator -g
express --view=pug myweb
express --view=pug thirdparty
</code></pre>

<p>在myweb中，index页面 <code>http://127.0.0.1:8085</code>需要跨域访问server中的<code>http://127.0.0.1:3000/info/normal</code>这个接口的信息。前端操作是：当点击<code>button</code>时就会去获取info，并alert出来。<br/>
跨域访问的接口<code>http://127.0.0.1:3000/info/normal</code>代码如下：</p>

<pre><code class="language-javascript">const express = require(&#39;express&#39;);
const router = express.Router();

const data = {
    name: &#39;alienzhou&#39;,
    desc: &#39;a developer&#39;
};

router.get(&#39;/normal&#39;, (req, res, next) =&gt; {
    res.json(data);
});
</code></pre>

<p>然后是<code>http://127.0.0.1:8085</code>index页面的部分的javascript</p>

<pre><code class="language-javascript">// http://127.0.0.1:8085  -- index.js
document.getElementById(&#39;btn-1&#39;).addEventListener(&#39;click&#39;, function() {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
            alert(xhr.responseText);
        }
    }
    xhr.open(&#39;get&#39;, &#39;http://127.0.0.1:3000/info/normal&#39;);
    xhr.send(null);
});
</code></pre>

<p>点击<code>btn-1</code>，在控制台中就会出现如下错误，这个跨域ajax请求受到了同源策略的限制。</p>

<pre><code>[Error] Origin http://127.0.0.1:8085 is not allowed by Access-Control-Allow-Origin.
[Error] Failed to load resource: Origin http://127.0.0.1:8085 is not allowed by Access-Control-Allow-Origin. (normal, line 0)
[Error] XMLHttpRequest cannot load http://127.0.0.1:3000/info/normal due to access control checks.
</code></pre>

<p>下面来讲具体的三种解决方案：</p>

<h3 id="toc_3">使用代理（proxy）</h3>

<p>这种方法本质上仍然遵循了同源政策，只是换了一个请求的思路，将请求移至了后端。</p>

<p>我们知道，同源政策是浏览器层面的限制。那么，如果我们不在前端跨域，而将“跨域”的任务交给后端服务，是否就规避了同源政策呢？是的。</p>

<p>这就是“代理”。这个代理可以将我们的请求转发，而后端并不会有所谓的同源政策限制。这个“代理”也可以理解为一个同域的后端服务。</p>

<p>由于我们的myweb是一个完整的web项目（包括前端部分和后端服务部分），因此，我们可以在myweb项目的后端添加一个<code>proxy</code>接口，专门处理跨域ajax请求的转发。</p>

<pre><code class="language-javascript">const express = require(&#39;express&#39;);
const router = express.Router();
const request = require(&#39;request&#39;);

router.get(&#39;*&#39;, (req, res, next) =&gt; {
    let path = req.path.replace(/^\/proxy/, &#39;&#39;);
    request.get(`http://127.0.0.1:3000${path}`, (err, response) =&gt; {
        res.json(JSON.parse(response.body));
    });
});

module.exports = router;
</code></pre>

<p>这样，我们在前端访问<code>/proxy/info/normal</code>后，就会自动转发到<code>http://127.0.0.1:3000/proxy/info/normal</code>。</p>

<p>前端ajax部分如下：</p>

<pre><code class="language-javascript">document.getElementById(&#39;btn-1&#39;).addEventListener(&#39;click&#39;, function() {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
            alert(xhr.responseText);
        }
    }
    xhr.open(&#39;get&#39;, &#39;/proxy/info/normal&#39;);
    xhr.send(null);
});
</code></pre>

<p>该方法的优点很明显：不需要第三方服务<code>http://127.0.0.1:3000/info/normal</code>进行任何改造。</p>

<p>当然，该方法也有一些缺点：</p>

<ul>
<li>首先，需要你有一个自己的后端服务能够接收并转发请求。如果你进行本地的纯静态页面开发，则需要一些浏览器插件或自动化工具中集成的本地服务器来实现。</li>
<li>此外，如果请求包含一些特殊的请求头（例如cookie等等），需要在转发时特殊处理。</li>
</ul>

<p>下面两种方法则需要第三方服务端或多或少进行配合改造。</p>

<h3 id="toc_4">CORS</h3>

<p>同源策略往往过于严格了，为了解决浏览器的这个问题，w3c提出了CORS（Cross-Origin Resource Sharing）标准。CORS通过相应的请求头与响应头来实现跨域资源访问。</p>

<p>如果我们打开控制台，可以在请求头中发现一个叫<code>origin</code>的头信息，它表明了请求的来源。这是浏览器自动添加的。</p>

<pre><code>Referer: http://127.0.0.1:8085/
Origin: http://127.0.0.1:8085   &lt;============   origin
Accept: */*
Cache-Control: no-cache
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/603.3.8 (KHTML, like Gecko) Version/10.1.2 Safari/603.3.8
Pragma: no-cache
</code></pre>

<p>与之对应的，服务器端的响应头中一个头信息为<code>Access-Control-Allow-Origin</code>，表明接受的跨域请求来源。显而易见，这两个信息如果一致，则这个请求就会被接受。</p>

<pre><code class="language-javascript">router.get(&#39;/cors&#39;, (req, res, next) =&gt; {
    res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;http://127.0.0.1:8085&#39;);
    res.json(data);
});
</code></pre>

<p>如果将<code>Access-Control-Allow-Origin</code>的值设置为<code>*</code>，则会接受所有域的请求。这时的客户端不需要任何配置即可进行跨域访问。</p>

<p>然而，还有一个问题，CORS默认是不会发送cookie，但是如果我希望这次的请求也能够带上对方服务所需的cookie怎么办？那就需要再进行一定的改造。</p>

<p>与<code>Access-Control-Allow-Origin</code>相配套的，还有一个叫<code>Access-Control-Allow-Credentials</code>的响应头，如果设置为<code>true</code>则表明服务器允许该请求内包含cookie信息。</p>

<pre><code class="language-javascript">router.get(&#39;/cors&#39;, (req, res, next) =&gt; {
    res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;http://127.0.0.1:8085&#39;);
    res.setHeader(&#39;Access-Control-Allow-Credentials&#39;, true);
    res.json(data);
});
</code></pre>

<p>同时，在客户端，还需要在ajax请求中设置<code>withCredentials</code>属性为<code>true</code>。</p>

<pre><code class="language-javascript">document.getElementById(&#39;btn-1&#39;).addEventListener(&#39;click&#39;, function() {
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = true;  // 设置withCredentials以便发送cookie
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
            alert(xhr.responseText);
        }
    }
    xhr.open(&#39;get&#39;, &#39;http://127.0.0.1:3000/info/cors&#39;);  // 跨域请求
    xhr.send(null);
});
</code></pre>

<p>可以看到，CORS方法有如下优点：</p>

<ul>
<li>简单，几乎不需要什么开发量，只需要简单配置相应的请求与响应头信息即可。</li>
<li>支持各种类型的请求（<code>get</code>, <code>post</code>, <code>put</code>等等）。</li>
</ul>

<p>但缺点是：</p>

<ul>
<li>需要对跨域的服务接口进行一定的改造。如果该服务因为某些原因无法改造，则无法实现。但这种改造还是相对较小的。</li>
<li>不兼容一些“古董”浏览器。</li>
</ul>

<h3 id="toc_5">jsonp</h3>

<p>jsonp是跨域领域中历史非常传统的一种方法。如果你还记得第一部分中我们提到过的内容，一些跨域请求是不会受到同源政策的限制的。其中，<code>script</code>标签就是一个。</p>

<p>在<code>script</code>标签中我们可以引用其他服务上的脚本，最常见的场景就是CDN。因此，有人想到，当有跨域请求到来时，如果我们可以把客户端需要的数据写到javascript脚本文件中并返回给客户端，那么客户端就可以拿到这些数据并使用了。具体是怎样一个流程呢？<br/>
1. 首先，在myweb端，我们可以预先定义一个处理函数，叫它<code>callback</code>；<br/>
2. 然后，在myweb端，我们动态创建一个script标签，并将该标签的<code>src</code>属性指向跨域的接口，并将<code>callback</code>函数名作为请求的参数；<br/>
3. 跨域的thirdparty端接受到该请求后，返回一个javascript脚本文件，用<code>callback</code>函数包裹住数据；<br/>
4. 这时候，前端收到响应数据会自动执行该脚本，这样便会自动执行预先定义的<code>callback</code>函数。</p>

<p>将上面这个方法具体成下面的代码：</p>

<pre><code class="language-javascript">// myweb 部分
// 1. 创建回调函数callback
function myCallback(res) {
    alert(JSON.stringify(res, null , 2));
}
document.getElementById(&#39;btn-4&#39;).addEventListener(&#39;click&#39;, function() {
    // 2. 动态创建script标签，并设置src属性，注意参数cb=myCallback
    var script = document.createElement(&#39;script&#39;);
    script.src = &#39;http://127.0.0.1:3000/info/jsonp?cb=myCallback&#39;;
    document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script);
});
</code></pre>

<pre><code class="language-javascript">// thirdparty
router.get(&#39;/jsonp&#39;, (req, res, next) =&gt; {
    var str = JSON.stringify(data);
    // 3. 创建script脚本内容，用`callback`函数包裹住数据
    // 形式：callback(data)
    var script = `${req.query.cb}(${str})`;
    res.send(script);
});
// 4. 前端收到响应数据会自动执行该脚本
</code></pre>

<p>当然，如果你是用类似jquery这样的库，其中的<code>$.ajax</code>本身是封装了JSONP方式的：</p>

<pre><code class="language-javascript">$.ajax({
    url: &#39;http://127.0.0.1:3000/info/jsonp?cb=myCallback&#39;,
    dataType: &#39;jsonp&#39;, // 注意，此处dataType的值表示请求使用JSONP
    jsonp: &#39;cb&#39;, // 请求query中callback函数的键名
}).done(function (res) {
    alert(JSON.stringify(res, null , 2));
});
</code></pre>

<p>JSONP作为一个久远的方法，其最大的优点就是兼容性非常好。</p>

<p>但是其缺点也很明显，由于是通过<code>script</code>标签发起的请求，因此只支持<code>get</code>请求。同时可以看到，较之CORS，其前后端改造开发量要稍高一些。如果跨域服务端不支持改造，那么也无法使用该方法。</p>

<hr/>

<p>上面三个方案的实例代码可以在这里（<a href="https://github.com/alienzhou/cross-domain-demo">cross-domain-demo</a>）clone到本地并运行。<code>git clone git@github.com:alienzhou/cross-domain-demo.git</code></p>

<h2 id="toc_6">总结</h2>

<p>同源策略作为浏览器的安全策略之一，在保证请求的安全性之外，也对我们的一些合理与期望的请求进行了控制。幸好，在面对跨域ajax请求时，我们还有一些方法可以应对它，包括使用代理、CORS和JSONP。在不同场景下合理运用各种方法，可以帮助我们有效解决ajax跨域问题。</p>

<hr/>

<h2 id="toc_7">Happy Coding！</h2>

<hr/>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="15236401468681.html"  title="Previous Post: Gulp.js实践详解__基于Gulp的多页面应用实践指南">&laquo; Gulp.js实践详解__基于Gulp的多页面应用实践指南</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="15236403350295.html" 
	        title="Next Post: JavaScript异步编程__“回调地狱”的一些解决方案">JavaScript异步编程__“回调地狱”的一些解决方案 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '15236404711802.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
