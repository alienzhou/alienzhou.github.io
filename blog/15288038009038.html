<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync - AlienZHOU's blog
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="AlienZHOU's blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">AlienZHOU's blog</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; AlienZHOU's blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>PWA</label></li>

          
            <li><a title="【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案" href="15288038664515.html">【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案</a></li>
          
            <li><a title="【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync" href="15288038009038.html">【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync</a></li>
          
            <li><a title="【PWA学习与实践】(7)使用Notification API来进行消息提醒" href="15288036503920.html">【PWA学习与实践】(7)使用Notification API来进行消息提醒</a></li>
          
            <li><a title="【PWA学习与实践】(6) 在Chrome中调试你的PWA" href="15288035758780.html">【PWA学习与实践】(6) 在Chrome中调试你的PWA</a></li>
          
            <li><a title="【PWA学习与实践】(5)在Web中进行服务端消息推送" href="15288030176091.html">【PWA学习与实践】(5)在Web中进行服务端消息推送</a></li>
          
            <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
          
            <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
          
            <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
          
            <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
          

      
        <li class="divider"></li>
        <li><label>React</label></li>

          
            <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
          
            <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
          

      
        <li class="divider"></li>
        <li><label>CSS</label></li>

          
            <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
          
            <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
          
            <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
          

      
        <li class="divider"></li>
        <li><label>Server</label></li>

          
            <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
          

      
        <li class="divider"></li>
        <li><label>Automation</label></li>

          
            <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
          

      
        <li class="divider"></li>
        <li><label>FE else</label></li>

          
            <li><a title="各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）" href="15288039493853.html">各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）</a></li>
          
            <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
          
            <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
          
            <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
          

      
        <li class="divider"></li>
        <li><label>Reading</label></li>

          
            <li><a title="推荐阅读 2018.06" href="15288017709756.html">推荐阅读 2018.06</a></li>
          
            <li><a title="推荐阅读 2018.05" href="15287963471356.html">推荐阅读 2018.05</a></li>
          
            <li><a title="推荐阅读 2018.04" href="15283399559020.html">推荐阅读 2018.04</a></li>
          
            <li><a title="推荐阅读 2018.03" href="15282529256902.html">推荐阅读 2018.03</a></li>
          

      
        <li class="divider"></li>
        <li><label>Performace</label></li>

          
            <li><a title="【性能优化实践】优化打包策略提升页面加载速度" href="15288037747207.html">【性能优化实践】优化打包策略提升页面加载速度</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>PWA</span></li>
                        
                          <li><a title="【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案" href="15288038664515.html">【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案</a></li>
                        
                          <li><a title="【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync" href="15288038009038.html">【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync</a></li>
                        
                          <li><a title="【PWA学习与实践】(7)使用Notification API来进行消息提醒" href="15288036503920.html">【PWA学习与实践】(7)使用Notification API来进行消息提醒</a></li>
                        
                          <li><a title="【PWA学习与实践】(6) 在Chrome中调试你的PWA" href="15288035758780.html">【PWA学习与实践】(6) 在Chrome中调试你的PWA</a></li>
                        
                          <li><a title="【PWA学习与实践】(5)在Web中进行服务端消息推送" href="15288030176091.html">【PWA学习与实践】(5)在Web中进行服务端消息推送</a></li>
                        
                          <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
                        
                          <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
                        
                          <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
                        
                          <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
                        

                    
                      <li class="side-title"><span>React</span></li>
                        
                          <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
                        
                          <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
                        

                    
                      <li class="side-title"><span>CSS</span></li>
                        
                          <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
                        
                          <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
                        
                          <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
                        

                    
                      <li class="side-title"><span>Server</span></li>
                        
                          <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
                        

                    
                      <li class="side-title"><span>Automation</span></li>
                        
                          <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
                        

                    
                      <li class="side-title"><span>FE else</span></li>
                        
                          <li><a title="各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）" href="15288039493853.html">各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）</a></li>
                        
                          <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
                        
                          <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
                        
                          <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
                        

                    
                      <li class="side-title"><span>Reading</span></li>
                        
                          <li><a title="推荐阅读 2018.06" href="15288017709756.html">推荐阅读 2018.06</a></li>
                        
                          <li><a title="推荐阅读 2018.05" href="15287963471356.html">推荐阅读 2018.05</a></li>
                        
                          <li><a title="推荐阅读 2018.04" href="15283399559020.html">推荐阅读 2018.04</a></li>
                        
                          <li><a title="推荐阅读 2018.03" href="15282529256902.html">推荐阅读 2018.03</a></li>
                        

                    
                      <li class="side-title"><span>Performace</span></li>
                        
                          <li><a title="【性能优化实践】优化打包策略提升页面加载速度" href="15288037747207.html">【性能优化实践】优化打包策略提升页面加载速度</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync</h1>

<p>本文是《PWA学习与实践》系列的第八篇文章。</p>

<p>PWA作为时下最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。</p>

<p>本系列文章《PWA学习与实践》会逐步拆解PWA背后的各项技术，通过实例代码来讲解这些技术的应用方式。也正是因为PWA中技术点众多、知识细碎，因此我在学习过程中，进行了整理，并产出了《PWA学习与实践》系列文章，希望能带大家全面了解PWA中的各项技术。对PWA感兴趣的朋友欢迎关注。</p>

<blockquote>
<p>本文中的代码可以在<a href="https://github.com/alienzhou/learning-pwa/tree/sync">learning-pwa的sync分支</a>上找到（<code>git clone</code>后注意切换到sync分支）。</p>
</blockquote>

<h2 id="toc_0">1. 引言</h2>

<p>生活中经常会有这样的场景：</p>

<p>用户拿出手机，浏览着我们的网站，发现了一个很有趣的信息，点击了“提交”按钮。然而不幸的是，这时用户到了一个网络环境极差的地方，或者是根本没有网络。他能够做的只有看着页面上的提示框和不断旋转的等待小圆圈。1s、5s、30s、1min……无尽的等待后，用户将手机放回了口袋，而这一次的请求也被终止了——由于当下极差的网络终止在了客户端。</p>

<p>上面的场景其实暴露了两个问题：</p>

<ol>
<li>普通的页面发起的请求会随着浏览器进程的结束/或者Tab页面的关闭而终止；</li>
<li>无网环境下，没有一种机制能“维持”住该请求，以待有网情况下再进行请求。</li>
</ol>

<p>然而，Service Worker的后台同步功能规避了这些缺陷。</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/13/163598ca174364ed?w=800&amp;h=499&amp;f=gif&amp;s=2269837" alt=""/></p>

<p>下面就让我们先来了解下后台同步（Background Sync）的工作原理。</p>

<h2 id="toc_1">2. 后台同步(Background Sync)是如何工作的？</h2>

<p>后台同步应该算是Service Worker相关功能（API）中比较易于理解与使用的一个。</p>

<p>其大致的流程如下：</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/13/1635905056b125a7?w=573&amp;h=129&amp;f=png&amp;s=8623" alt=""/></p>

<ol>
<li>首先，你需要在Service Worker中监听sync事件；</li>
<li>然后，在浏览器中发起后台同步sync（图中第一步）；</li>
<li>之后，会触发Service Worker的sync事件，在该监听的回调中进行操作，例如向后端发起请求（图中第二步）</li>
<li>最后，可以在Service Worker中对服务端返回的数据进行处理。</li>
</ol>

<p>由于Service Worker在用户关闭该网站后仍可以运行，因此该流程名为“后台同步”实在是非常贴切。</p>

<p>怎么样，在我们已经有了一定的Service Worker基础之后，后台同步这一功能相比之前的功能，是不是非常易于理解？</p>

<h2 id="toc_2">3. 如何使用后台同步功能？</h2>

<p>既然已经理解了该功能的大致流程，那么接下来就让我们来实际操作一下吧。</p>

<h3 id="toc_3">3.1 client触发sync事件</h3>

<pre><code class="language-javascript">// index.js
navigator.serviceWorker.ready.then(function (registration) {
    var tag = &quot;sample_sync&quot;;
    document.getElementById(&#39;js-sync-btn&#39;).addEventListener(&#39;click&#39;, function () {
        registration.sync.register(tag).then(function () {
            console.log(&#39;后台同步已触发&#39;, tag);
        }).catch(function (err) {
            console.log(&#39;后台同步触发失败&#39;, err);
        });
    });
});
</code></pre>

<p>由于后台同步功能需要在Service Worker注册完成后触发，因此较好的一个方式是在<code>navigator.serviceWorker.ready</code>之后绑定相关操作。例如上面的代码中，我们在ready后绑定了按钮的点击事件。当按钮被点击后，会使用<code>registration.sync.register()</code>方法来触发Service Worker的sync事件。</p>

<p><code>registration.sync</code>返回一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/SyncManager"><code>SyncManager</code>对象</a>，其上包含<code>register</code>和<code>getTags</code>两个方法：</p>

<blockquote>
<p><code>register()</code> Create a new sync registration and return a Promise. </p>

<p><code>getTags()</code> Return a list of developer-defined identifiers for SyncManager registration.</p>
</blockquote>

<p><code>register()</code>方法可以注册一个后台同步事件，其中接收的参数<code>tag</code>用于作为这个后台同步的唯一标识。</p>

<p>当然，如果想要代码更健壮的话，我们还需要在调用前进行特性检测：</p>

<pre><code class="language-javascript">// index.js
if (&#39;serviceWorker&#39; in navigator &amp;&amp; &#39;SyncManager&#39; in window) {
    // ……
}
</code></pre>

<h3 id="toc_4">3.2 在Service Worker中监听sync事件</h3>

<p>当client触发了sync事件后，剩下的就交给Service Worker。理论上此时就不需要client（前端站点）参与了。例如另一个经典场景：用户离开时页面（unload）时在client端触发sync事件，剩下的操作交给Service Worker，Service Worker的操作可以在离开页面后正常进行。</p>

<p>像添加fetch和push事件监听那样，我们可以为Service Worker添加sync事件的监听：</p>

<pre><code class="language-javascript">// sw.js
self.addEventListener(&#39;sync&#39;, function (e) {
    // ……
});
</code></pre>

<p>在sync事件的event对象上可以取到tag值，该值就是我们在上一节注册sync时的唯一标识。通过这个tag就可以区分出不同的后台同步事件。例如，当该值为&#39;sample_sync&#39;时我们向后端发送一个请求：</p>

<pre><code class="language-javascript">// sw.js
self.addEventListener(&#39;sync&#39;, function (e) {
    console.log(`service worker需要进行后台同步，tag: ${e.tag}`);
    var init = {
        method: &#39;GET&#39;
    };
    if (e.tag === &#39;sample_sync&#39;) {
        var request = new Request(`sync?name=AlienZHOU`, init);
        e.waitUntil(
            fetch(request).then(function (response) {
                response.json().then(console.log.bind(console));
                return response;
            })
        );
    }
});
</code></pre>

<p>这里我通过<code>e.tag</code>来判断client触发的不同sync事件，并在监听到tag为&#39;sample_sync&#39;的sync事件后，构建了一个request对象，使用fetch API来进行后端请求。</p>

<p>需要特别注意的是，fetch请求一定要放在<code>e.waitUntil()</code>内。因为我们要保证“后台同步”，将Promise对象放在<code>e.waitUntil()</code>内可以确保在用户离开我们的网站后，Service Worker会持续在后台运行，等待该请求完成。</p>

<h3 id="toc_5">3.3 完善我们的后端服务</h3>

<p>实际上，经过上面两小节，我们的大致工作已经完成。不过还缺少一个小环节：我们的KOA服务器上还没有sync路由和接口。添加一下，以保证demo可以正常运行：</p>

<pre><code class="language-javascript">// app.js
router.get(&#39;/sync&#39;, async (ctx, next) =&gt; {
    console.log(`Hello ${ctx.request.query.name}, I have received your msg`);
    ctx.response.body = {
        status: 0
    };
});
</code></pre>

<h3 id="toc_6">3.4 Demo效果展示</h3>

<p>下面就来看一下这个demo的运行效果：</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/13/1635975104e68836?w=800&amp;h=499&amp;f=gif&amp;s=1947627" alt=""/></p>

<p>可以看到，在网络环境正常的情况下，点击“同步”按钮会立即触发Service Worker中的sync事件监听，并向服务端发送请求；而在断网情况下，点击“同步”按钮，控制台虽然显示注册了同步事件，但是并不会触发Service Worker的sync监听回调，指到恢复网络连接，才会在后台（Service Worker）中进行相关处理。</p>

<p>下面再来看一下触发sync事件后，关闭网站的效果：</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/13/163598ca174364ed?w=800&amp;h=499&amp;f=gif&amp;s=2269837" alt=""/></p>

<p>可以看到，即使在关闭网站后再重新连接网络，服务端依然可以收到来自客户端的请求（说明Service Worker在后台进行了相关处理）。</p>

<h2 id="toc_7">4. 如何在后台同步时获取所需的数据？</h2>

<p>其实上一节结束，我们就已经可以了解最基础的后台同步功能了。而这部分则会进一步探讨后台同步中的一个重要问题：如何在后台同步时获取并发送client中的数据？</p>

<p>例如在我们的上一个Demo中，用户的姓名name是硬编码在Service Worker中的，而实际上，我们希望能在页面上提供一个输入框，将用户的输入内容在后台同步中进行发送。</p>

<p>实现的方式有两种：使用postMessage或使用indexedDB。</p>

<h3 id="toc_8">4.1 使用postMessage</h3>

<p>我们知道，在浏览器主线程与Web Worker线程之间可以通过postMessage来进行通信。因此，我们也可以使用这个方法来向Service Worker“传输”数据。</p>

<p>大致思路如下：</p>

<ol>
<li>client触发sync事件；</li>
<li>在sync注册完成后，使用postMessage和Service Worker通信；</li>
<li>在Service Worker的sync事件回调中等待message事件的消息；</li>
<li>收到message事件的消息后，将其中的信息提交到服务端。</li>
</ol>

<pre><code class="language-javascript">// index.js
// 使用postMessage来传输sync数据
navigator.serviceWorker.ready.then(function (registration) {
    var tag = &#39;sample_sync_event&#39;;

    document.getElementById(&#39;js-sync-event-btn&#39;).addEventListener(&#39;click&#39;, function () {
        registration.sync.register(tag).then(function () {
            console.log(&#39;后台同步已触发&#39;, tag);

            // 使用postMessage进行数据通信
            var inputValue = document.querySelector(&#39;#js-search-input&#39;).value;
            var msg = JSON.stringify({type: &#39;bgsync&#39;, msg: {name: inputValue}});
            navigator.serviceWorker.controller.postMessage(msg);
        }).catch(function (err) {
            console.log(&#39;后台同步触发失败&#39;, err);
        });
    });
});
</code></pre>

<p>在<code>registration.sync.register</code>完成后，调用<code>navigator.serviceWorker.controller.postMessage</code>来向Service Worker Post数据。</p>

<p>为了提高代码的可维护性，我在sw.js中创建了一个<code>SimpleEvent</code>类，你可以把它看做一个最简单的EventBus。用来解耦Service Worker的message事件和sync事件。</p>

<pre><code class="language-javascript">// sw.js
class SimpleEvent {
    constructor() {
        this.listenrs = {};
    }

    once(tag, cb) {
        this.listenrs[tag] || (this.listenrs[tag] = []);
        this.listenrs[tag].push(cb);
    }

    trigger(tag, data) {
        this.listenrs[tag] = this.listenrs[tag] || [];
        let listenr;
        while (listenr = this.listenrs[tag].shift()) {
            listenr(data)
        }
    }
}
</code></pre>

<p>在message事件中监听client发来的消息，并通过SimpleEvent通知所有监听者。</p>

<pre><code class="language-javascript">// sw.js
const simpleEvent = new SimpleEvent();
self.addEventListener(&#39;message&#39;, function (e) {
    var data = JSON.parse(e.data);
    var type = data.type;
    var msg = data.msg;
    console.log(`service worker收到消息 type：${type}；msg：${JSON.stringify(msg)}`);

    simpleEvent.trigger(type, msg);
});
</code></pre>

<p>在sync事件中，使用SimpleEvent监听bgsync来获取数据，然后再调用fetch方法。注意，由于<code>e.waitUntil()</code>需要接收Promise作为参数，因此需要对<code>SimpleEvent.once</code>进行Promisfy。</p>

<pre><code class="language-javascript">// sw.js
self.addEventListener(&#39;sync&#39;, function (e) {
    if (e.tag === xxx) {
        // ……
    }

    // sample_sync_event同步事件，使用postMessage来进行数据通信
    else if (e.tag === &#39;sample_sync_event&#39;) {
        // 将SimpleEvent.once封装为Promise调用
        let msgPromise = new Promise(function (resolve, reject) {
            // 监听message事件中触发的事件通知
            simpleEvent.once(&#39;bgsync&#39;, function (data) {
                resolve(data);
            });
            // 五秒超时
            setTimeout(resolve, 5000);
        });

        e.waitUntil(
            msgPromise.then(function (data) {
                var name = data &amp;&amp; data.name ? data.name : &#39;anonymous&#39;;
                var request = new Request(`sync?name=${name}`, init);
                return fetch(request)
            }).then(function (response) {
                response.json().then(console.log.bind(console));
                return response;
            })
        );
    }
});
</code></pre>

<p>是不是非常简单？</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635a5723bed476c?w=800&amp;h=499&amp;f=gif&amp;s=2772919" alt=""/></p>

<p>进行后台同步时，使用postMessage来实现client向Service Worker的传输数据，方便与直观，是一个不错的方法。</p>

<h3 id="toc_9">4.2 使用indexedDB</h3>

<p>在client与Servcie Worker之间同步数据，还有一个可行的思路：client先将数据存在某处，待Servcie Worker需要时再读取使用即可。</p>

<p>为此需要找一个存数据的地方。你第一个想到的可能就是localStorage了。</p>

<p>然而，不知道你是否还记得我在最开始介绍Service Worker时所提到的，为了保证性能，实现部分操作的非阻塞，在Service Worker中我们经常会碰到异步操作（因此大多数API都是Promise形式的）。那么像localStorage这样的同步API会变成异步化么？答案很简单：不会，并且localStorage在Servcie Worker中无法调用。</p>

<p>不过不要气馁，我们还另一个强大的数据存储方式——indexedDB。它是可以在Service Worker中使用的。对于indexedDB的使用方式，本系列后续会有文章具体介绍，因此在这里的就不重点讲解indexedDB的使用方式了。</p>

<p>首先，需要一个方法用于连接数据库并创建相应的store：</p>

<pre><code class="language-javascript">// index.js
function openStore(storeName) {
    return new Promise(function (resolve, reject) {
        if (!(&#39;indexedDB&#39; in window)) {
            reject(&#39;don\&#39;t support indexedDB&#39;);
        }
        var request = indexedDB.open(&#39;PWA_DB&#39;, 1);
        request.onerror = function(e) {
            console.log(&#39;连接数据库失败&#39;);
            reject(e);
        }
        request.onsuccess = function(e) {
            console.log(&#39;连接数据库成功&#39;);
            resolve(e.target.result);
        }
        request.onupgradeneeded = function (e) {
            console.log(&#39;数据库版本升级&#39;);
            var db = e.srcElement.result;
            if (e.oldVersion === 0) {
                if (!db.objectStoreNames.contains(storeName)) {
                    var store = db.createObjectStore(storeName, {
                        keyPath: &#39;tag&#39;
                    });
                    store.createIndex(storeName + &#39;Index&#39;, &#39;tag&#39;, {unique: false});
                    console.log(&#39;创建索引成功&#39;);
                }
            }
        }
    });
}
</code></pre>

<p>然后，在<code>navigator.serviceWorker.ready</code>中打开该数据库连接，并在点击按钮时，先将数据存入indexedDB，再注册sync：</p>

<pre><code class="language-javascript">// index.js
navigator.serviceWorker.ready.then(function (registration) {
    return Promise.all([
        openStore(STORE_NAME),
        registration
    ]);
}).then(function (result) {
    var db = result[0];
    var registration = result[1];
    var tag = &#39;sample_sync_db&#39;;

    document.getElementById(&#39;js-sync-db-btn&#39;).addEventListener(&#39;click&#39;, function () {
        // 将数据存储进indexedDB
        var inputValue = document.querySelector(&#39;#js-search-input&#39;).value;
        var tx = db.transaction(STORE_NAME, &#39;readwrite&#39;);
        var store = tx.objectStore(STORE_NAME);
        var item = {
            tag: tag,
            name: inputValue
        };
        store.put(item);

        registration.sync.register(tag).then(function () {
            console.log(&#39;后台同步已触发&#39;, tag);
        }).catch(function (err) {
            console.log(&#39;后台同步触发失败&#39;, err);
        });
    });
});
</code></pre>

<p>同样的，在Service Worker中也需要相应的数据库连接方法：</p>

<pre><code class="language-javascript">// sw.js
function openStore(storeName) {
    return new Promise(function (resolve, reject) {
        var request = indexedDB.open(&#39;PWA_DB&#39;, 1);
        request.onerror = function(e) {
            console.log(&#39;连接数据库失败&#39;);
            reject(e);
        }
        request.onsuccess = function(e) {
            console.log(&#39;连接数据库成功&#39;);
            resolve(e.target.result);
        }
    });
}
</code></pre>

<p>并且在sync事件的回调中，get到indexedDB中对应的数据，最后再向后端发送请求：</p>

<pre><code class="language-javascript">// index.js
self.addEventListener(&#39;sync&#39;, function (e) {
    if (e.tag === xxx) {
        // ……
    }
    else if (e.tag === yyy) {
        // ……
    }
    
    // sample_sync_db同步事件，使用indexedDB来获取需要同步的数据
    else if (e.tag === &#39;sample_sync_db&#39;) {
        // 将数据库查询封装为Promise类型的请求
        var dbQueryPromise = new Promise(function (resolve, reject) {
            var STORE_NAME = &#39;SyncData&#39;;
            // 连接indexedDB
            openStore(e.tag).then(function (db) {
                try {
                    // 创建事务进行数据库查询
                    var tx = db.transaction(STORE_NAME, &#39;readonly&#39;);
                    var store = tx.objectStore(STORE_NAME);
                    var dbRequest = store.get(e.tag);
                    dbRequest.onsuccess = function (e) {
                        resolve(e.target.result);
                    };
                    dbRequest.onerror = function (err) {
                        reject(err);
                    };
                }
                catch (err) {
                    reject(err);
                }
            });
        });

        e.waitUntil(
            // 通过数据库查询获取需要同步的数据
            dbQueryPromise.then(function (data) {
                console.log(data);
                var name = data &amp;&amp; data.name ? data.name : &#39;anonymous&#39;;
                var request = new Request(`sync?name=${name}`, init);
                return fetch(request)
            }).then(function (response) {
                response.json().then(console.log.bind(console));
                return response;
            })
        );
    }
});
</code></pre>

<p>相比于postMessage，使用indexedDB的方案要更复杂一点。它比较适用于一些需要数据持久化的场景。</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635a579ba845ce7?w=800&amp;h=499&amp;f=gif&amp;s=953776" alt=""/></p>

<h2 id="toc_10">5. 兼容性</h2>

<p>依照惯例，我们还是来简单看一下文中相关功能的兼容性。</p>

<p>先是<a href="https://caniuse.com/#search=Background%20Sync%20API">Background Sync</a>：</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/13/16359f504955c8b8?w=1240&amp;h=592&amp;f=png&amp;s=134469" alt=""/></p>

<p>令人悲伤的是，基本只有Google自家的Chrome可用。</p>

<p>然后是<a href="https://caniuse.com/#search=indexedDB">indexedDB</a>：</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/13/16359f671e79ba6b?w=1240&amp;h=580&amp;f=png&amp;s=155435" alt=""/></p>

<p>相较于Background Sync还是有着不错的兼容性的。而且在safari（包括iOS safari）中也得到了支持。</p>

<h2 id="toc_11">6. 写在最后</h2>

<p>从文中的内容以及<a href="https://developers.google.com/web/updates/2015/12/background-sync#the_solution">google developer中的一些实例</a>来看，Background Sync是一个非常有潜力的API。然而令人堪忧的兼容性在一定程度上限制了它的发挥空间。不过，作为一项技术，还是非常值得我们学习与了解的。</p>

<p>本文中所有的代码示例均可以在<a href="https://github.com/alienzhou/learning-pwa/tree/sync">learn-pwa/sync</a>上找到。</p>

<p>如果你喜欢或想要了解更多的PWA相关知识，欢迎关注我，关注<a href="https://juejin.im/user/59ad5377518825244d206d2d/posts">《PWA学习与实践》</a>系列文章。我会总结整理自己学习PWA过程的遇到的疑问与技术点，并通过实际代码和大家一起实践。</p>

<p>到目前为止，我们已经学习了PWA中的多个知识点，在其基础上，已经可以帮助我们进行原有站点的PWA升级。学习是一方面，实践是另一方面。在下一篇文章里，我会整理一些在业务中升级PWA时碰到的问题，以及对应的解决方案。</p>

<h2 id="toc_12">参考资料</h2>

<ul>
<li><a href="https://wicg.github.io/BackgroundSync/spec/">Web Background Synchronization</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SyncManager">MDN: SyncManager</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SyncManager/register">MDN: SyncManager.register()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SyncRegistration">MDN: SyncRegistration</a></li>
<li><a href="https://developers.google.com/web/updates/2015/12/background-sync">Introducing Background Sync</a></li>
</ul>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="15288038664515.html"  title="Previous Post: 【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案">&laquo; 【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="15288037747207.html" 
	        title="Next Post: 【性能优化实践】优化打包策略提升页面加载速度">【性能优化实践】优化打包策略提升页面加载速度 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '15288038009038.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
