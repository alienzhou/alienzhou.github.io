<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  React - AlienZHOU's blog
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="AlienZHOU's blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">AlienZHOU's blog</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; AlienZHOU's blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>PWA</label></li>

          
            <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
          
            <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
          
            <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
          
            <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
          

      
        <li class="divider"></li>
        <li><label>React</label></li>

          
            <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
          
            <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
          

      
        <li class="divider"></li>
        <li><label>CSS</label></li>

          
            <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
          
            <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
          
            <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
          

      
        <li class="divider"></li>
        <li><label>Server</label></li>

          
            <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
          

      
        <li class="divider"></li>
        <li><label>Automation</label></li>

          
            <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
          

      
        <li class="divider"></li>
        <li><label>FE else</label></li>

          
            <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
          
            <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
          
            <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>PWA</span></li>
                        
                          <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
                        
                          <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
                        
                          <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
                        
                          <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
                        

                    
                      <li class="side-title"><span>React</span></li>
                        
                          <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
                        
                          <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
                        

                    
                      <li class="side-title"><span>CSS</span></li>
                        
                          <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
                        
                          <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
                        
                          <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
                        

                    
                      <li class="side-title"><span>Server</span></li>
                        
                          <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
                        

                    
                      <li class="side-title"><span>Automation</span></li>
                        
                          <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
                        

                    
                      <li class="side-title"><span>FE else</span></li>
                        
                          <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
                        
                          <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
                        
                          <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 


	
		<div class="markdown-body">
		<h1>基于react技术栈的单页应用(SPA)搭建_快速入门实践</h1>

		<h2 id="toc_0">概述</h2>

<p>本篇文章使用create-react-app作为脚手架，结合react技术栈（react + redux + react-router），构建一个简单的单页面应用demo。文章会一步步地讲解如何构建这么一个单页应用。<strong><em>文章的最后也会给出相应的demo地址</em></strong>。</p>

<p>本文主要是对SPA搭建的实践过程讲解，在对react、redux、react-router有了初步了解后，来运用这些技术构建一个简单的单页应用。这个应用包括了侧边导航栏与主体内容区域。下面简单罗列了将会用到的一些框架与工具。</p>

<ul>
<li>create-react-app：脚手架</li>
<li>react：负责页面组件构建</li>
<li>react-router：负责单页应用路由部分的控制</li>
<li>redux：负责管理整个应用的数据流</li>
<li>react-redux：将react与redux这两部分相结合</li>
<li>redux-thunk：redux的一个中间件。可以使action creator返回一个<code>function</code>（而不仅仅是<code>object</code>），并且使得dispatch方法可以接收一个<code>function</code>作为参数，通过这种改造使得action支持异步（或延迟）操作</li>
<li>redux-actions：针对redux的一个FSA工具箱，可以相应简化与标准化action与reducer部分</li>
</ul>

<p>好了，话不多说，一起来构建你的单页应用吧。</p>

<h2 id="toc_1">使用create-react-app脚手架</h2>

<p><a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>是Facebook官方出品的脚手架。有了它，你只需要一行指令即可跳过webpack繁琐的配置、npm繁多的引入等过程，迅速构建react项目。</p>

<p>首先安装create-react-app</p>

<pre><code class="language-bash">npm i -g create-react-app
</code></pre>

<p>安装完成后，就可以使用<code>create-react-app</code>指令快速创建一个基于webpack的react应用程序</p>

<pre><code class="language-bash">cd $your_dir
create-react-app react-redux-demo
</code></pre>

<p>这时你可以进入<code>react-redux-demo</code>这个目录，运行<code>npm start</code>既可启动该应用。</p>

<p>打开访问<code>localhost:3000</code>看到下方对应的页面，就说明项目基础框架创建完毕了。<br/>
<img src="http://upload-images.jianshu.io/upload_images/6476654-ceeeda7ba166a8fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="启动页面"/></p>

<h2 id="toc_2">创建React组件</h2>

<h3 id="toc_3">修改目录结构</h3>

<p>下面在我们的react-redux-demo项目，查看一下相应的目录结构</p>

<pre><code>|--public
    |--index.html
    |-- ……
|--src
    |--App.js
    |--index.js
    |-- ……
|--node_modules
</code></pre>

<p>其中<code>public</code>中存放的内容不会被webpack编译，所以可以放一些静态页面或图片；<code>src</code>中存放的内容才会被webpack打包编译，我们主要工作的目录就是在<code>src</code>下。</p>

<p>了解react的同学肯定知道，在react中我们通过构建各种<code>react component</code>来实现一个新的世界。在我们的项目里，会基于此，将组件分为通用组件部分与页面组件部分。通用组件也就是我们普遍意义上的组件，一些大型项目会维护一个自己的组件库，其中的组件会被整个项目共享；页面组件实际上就是我们项目中所呈现出来的各个页面。因此，我们的目录会变成这样</p>

<pre><code>|--public
      |--index.html
      |-- ……
|--src
    |--page
         |--welcome.js
         |--goods.js
    |--component
         |--nav
             |--index.js
             |--index.css
    |--App.js
    |--index.js
    |-- ……
|--node_modules
</code></pre>

<p>在<code>src</code>目录下新建了<code>page</code>和<code>component</code>两个目录分别用于存放页面组件和通用组件。页面组件包括<code>welcome.js</code>和商品列表页<code>good.js</code>，通用组件包括了一个导航栏<code>nav</code>。</p>

<h3 id="toc_4">两种组件形式</h3>

<p>编写页面或组件，类似于静态页的开发。推荐的组件写法有两种：</p>

<p><strong>1）纯函数形式</strong>：该类组件为无状态组件。由于使用函数来定义，因此不能访问<code>this</code>对象，同时也没有生命周期方法，只能访问<code>props</code>。这类组件主要是一些纯展示类的小组件，通过将这些小组件进行组合构成更为复杂的组件。例如：</p>

<pre><code class="language-javascript">const Title = props =&gt; (
    &lt;h1&gt;
        {props.title} - {props.subtitle}
    &lt;/h1&gt;
)
</code></pre>

<p><strong>2）es6形式的组件</strong>：该类组件一般为复杂的或有状态组件。使用es6的class语法进行创建。需要注意的是，在页面/组件中使用<code>this</code>注意其指向，必要时需要绑定。绑定方法可以使用<code>bind</code>函数或箭头函数。创建方式如下：</p>

<pre><code class="language-javascript">class Title extends Component {
    constructor(props) {
        super(props);
        this.state = {
            shown: true
        };
    }
    
    render() {
        let style = {
            display: this.state.shown ? &#39;block&#39; : none
        };
        return (
            &lt;h1 style={style}&gt;
                {props.title} - {props.subtitle}
            &lt;/h1&gt;
        );
    }
}
</code></pre>

<p>下面是这两种组件之间的对比：</p>

<table>
<thead>
<tr>
<th> </th>
<th>Presentational Components</th>
<th>Container Components</th>
</tr>
</thead>

<tbody>
<tr>
<td>Purpose</td>
<td>How things look (markup, styles)</td>
<td>How things work (data fetching, state updates)</td>
</tr>
<tr>
<td>Aware of Redux</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>To read data</td>
<td>Read data from props</td>
<td>Subscribe to Redux state</td>
</tr>
<tr>
<td>To change data</td>
<td>Invoke callbacks from props</td>
<td>Dispatch Redux actions</td>
</tr>
<tr>
<td>Are written</td>
<td>By hand</td>
<td>Usually generated by React Redux</td>
</tr>
</tbody>
</table>

<p>鉴于上面的分析，我们可以将导航栏<code>nav</code>编写为无状态组件，而<code>page</code>中的部分使用有状态的组件。</p>

<p>导航栏组件<code>nav</code></p>

<pre><code class="language-javascript">// component/nav/index.css
.nav {
    margin: 30px;
    padding: 0;
}
.nav li {
    border-left: 5px solid sandybrown;
    margin: 15px 0;
    padding: 6px 0;
    color: #333;
    list-style: none;
    background: #bbb;
}

// component/nav/index.js
import React from &#39;react&#39;;
import &#39;./index.css&#39;;

const Nav = props =&gt; (
    &lt;ul className=&quot;nav&quot;&gt;
        {
            props.list.map((ele, idx) =&gt; (
                &lt;li key={idx}&gt;{ele.text}&lt;/li&gt;
            ))
        }
    &lt;/ul&gt;
);

export default Nav;
</code></pre>

<p>修改后的<code>App.js</code>与<code>App.css</code></p>

<pre><code class="language-javascript">// App.css
.App {
    text-align: center;
}
.App::after {
    clear: both;
}
.nav_bar {
    float: left;
    width: 300px;
}
.conent {
    margin-left: 300px;
    padding: 30px;
}

// App.js
import React, { Component } from &#39;react&#39;;
import Nav from &#39;./component/nav&#39;;
import Welcome from &#39;./page/welcome&#39;;
import Goods from &#39;./page/goods&#39;;
import &#39;./App.css&#39;;

const LIST = [{
    text: &#39;welcome&#39;,
    url: &#39;/welcome&#39;
}, {
    text: &#39;goods&#39;,
    url: &#39;/goods&#39;
}];

const GOODS = [{
    name: &#39;iPhone 7&#39;,
    price: &#39;6,888&#39;,
    amount: 37
}, {
    name: &#39;iPad&#39;,
    price: &#39;3,488&#39;,
    amount: 82
}, {
    name: &#39;MacBook Pro&#39;,
    price: &#39;11,888&#39;,
    amount: 15
}];

class App extends Component {
    render() {
        return (
            &lt;div className=&quot;App&quot;&gt;
                &lt;div className=&quot;nav_bar&quot;&gt;
                    &lt;Nav list={LIST} /&gt;
                &lt;/div&gt;
                &lt;div className=&quot;conent&quot;&gt;
                    &lt;Welcome /&gt;
                    &lt;Goods list={GOODS} /&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}

export default App;
</code></pre>

<p>welcome页面</p>

<pre><code class="language-javascript">// page/welcome.js
import React from &#39;react&#39;;

const Welcome = props =&gt; (
    &lt;h1&gt;Welcome!&lt;/h1&gt;
);

export default Welcome;
</code></pre>

<p>goods页面</p>

<pre><code class="language-javascript">// page/goods.js
import React, { Component } from &#39;react&#39;;

class Goods extends Component {
    render() {
        return (
            &lt;ul className=&quot;goods&quot;&gt;
                {
                    this.props.list.map((ele, idx) =&gt; (
                        &lt;li key={idx} style={{marginBottom: 20, listStyle: &#39;none&#39;}}&gt;
                            &lt;span&gt;{ele.name}&lt;/span&gt; | 
                            &lt;span&gt;￥ {ele.price}&lt;/span&gt; | 
                            &lt;span&gt;剩余 {ele.amount} 件&lt;/span&gt;
                        &lt;/li&gt;
                    ))
                }
            &lt;/ul&gt;
        );
    }
}

export default Goods;
</code></pre>

<p>现在我们的页面是这样的</p>

<p><img src="http://upload-images.jianshu.io/upload_images/6476654-48a1dac919bf9f16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/></p>

<h2 id="toc_5">使用redux来管理数据流</h2>

<p><img src="http://upload-images.jianshu.io/upload_images/6476654-218811ebec26b62a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redux数据流示意图"/><br/>
redux是flux架构的一种实现。图中展示了，在react+redux框架下，一个点击事件是如何进行交互的。</p>

<p>然而redux并不是完全依附于react的框架，实际上redux是可以和任何UI层框架相结合的。因此，为了更好得结合redux与react，对redux-flow中的<code>store</code>有一个更好的全局性管理，我们还需要使用<code>react-redux</code>。</p>

<pre><code class="language-bash">npm i --save redux
npm i --save react-redux
</code></pre>

<p>同时，为了更好地创建action和reducer，我们还会在项目中引入<code>redux-actions</code>：一个针对redux的一个FSA工具箱，可以相应简化与标准化action与reducer部分。当然，这是可选的</p>

<pre><code class="language-bash">npm i --save redux-actions
</code></pre>

<p>下面我们会以goods页面为例，实现以下场景：goods页面组件渲染完成后，发送请求，获取商品列表。其中获取数据的方法会使用mock数据。</p>

<p>为了实现这些功能，我们需要进一步调整目录结构</p>

<pre><code>|--public
      |--index.html
      |-- ……
|--src
    |--page
         |--welcome.js
         |--goods.js
    |--component
         |--nav
             |--index.js
             |--index.css
    |--action
         |--goods.js
    |--reducer
         |--goods.js
         |--index.js
    |--App.js
    |--index.js
    |-- ……
|--node_modules
</code></pre>

<h3 id="toc_6">首先，创建action</h3>

<p>首先，我们要创建对应的action。</p>

<p>action是一个<code>object</code>类型，对于action的结构有Flux有相关的标准化建议<a href="https://github.com/acdlite/flux-standard-action">FSA</a><br/>
一个action必须要包含<code>type</code>属性，同时它还有三个可选属性<code>error</code>、<code>payload</code>和<code>meta</code>。<br/>
- type属性相当于是action的标识，通过它可以区分不同的action，其类型只能是字符串常量或<code>Symbol</code>。<br/>
- payload属性是可选的，可以使任何类型。payload可以用来装载数据；在error为true的时候，payload一般是用来装载错误信息。<br/>
- error属性是可选的，一般当出现错误时其值为true；如果是其他值，不被理解为出现错误。<br/>
- meta属性可以使任何类型，它一般会包括一些不适合在payload中放置的数据。</p>

<p>我们可以创建一个获取goods信息的action：</p>

<pre><code class="language-javascript">// action/goods.js
const getGoods = goods =&gt; {
    return {
        type: &#39;GET_GOODS&#39;,
        payload: goods
    };
}
</code></pre>

<p>这样，我们就可以得到<code>GET_GOODS</code>这个action。</p>

<p>在项目中，使用redux-actions对actions进行创建与管理：</p>

<pre><code class="language-javascript">createAction(type, payloadCreator = Identity, ?metaCreator)
</code></pre>

<p><code>createAction</code>相当于对action创建器的一个包装，会返回一个FSA，使用这个返回的FSA可以创建具体的action。</p>

<p><code>payloadCreator</code>是一个<code>function</code>，处理并返回需要的payload；如果空缺，会使用默认方法。如果传入一个<code>Error</code>对象则会自动将action的error属性设为<code>true</code>：</p>

<pre><code class="language-javascript">example = createAction(&#39;EXAMLE&#39;, data =&gt; data);
// 和下面的使用效果一样
example = createAction(&#39;EXAMLE&#39;);
</code></pre>

<p>因此上面的方式可以改写为：</p>

<pre><code class="language-javascript">// action/goods.js
import {createAction} from &#39;redux-actions&#39;;
export const getGoods = createAction(&#39;GET_GOODS&#39;); 
</code></pre>

<p>* 此外，还可以使用<code>createActions</code>同时创建多个action creators。</p>

<h3 id="toc_7">其次，创建state的处理方法——reducer</h3>

<p>针对不同的action，会有不同的reducer对应进行state处理，它们通过type的值相互对应。<br/>
reducer是一个处理state的方法（function），该方法接收两个参数，当前状态<code>state</code>和对应的<code>action</code>。根据<code>state</code>与<code>action</code>，reducer会进行处理并返回一个新的<code>state</code>（同时也是一个新的<code>object</code>，而不去修改原<code>state</code>）。可以通过简单的switch操作来实现：</p>

<pre><code class="language-javascript">// reducer/goods.js
const goods = (state, action) =&gt; {
    switch (action.type) {
        case &#39;GET_GOODS&#39;:
            return {
                ...state,
                data: action.payload
            };
        // 其他action处理……
    }
}
</code></pre>

<p>对应<code>createAction</code>，<code>redux-actions</code>也有相应的reducer方式：</p>

<pre><code class="language-javascript">handleAction(type, reducer | reducerMap = Identity, defaultState)
</code></pre>

<p><code>type</code>可以是字符串，也可以是<code>createAction</code>返回的action创建器：</p>

<pre><code class="language-javascript">handleAction(&#39;GET_GOODS&#39;, {
    next(state, action) {...},
    throw(state, action) {...}
}, defaultState);

//或者可以是
handleAction(getGoods, {
    next(state, action) {...},
    throw(state, action) {...}
}, defaultState);
</code></pre>

<p>此外，有时候一些操作的一系列action可以在语义和业务逻辑上是有一定联系的，我们希望将他们放在一起便于维护。可以通过<code>handleActions</code>方法将多个相关的reducer写在一起，以便于后期维护：</p>

<pre><code class="language-javascript">handleActions(reducerMap, defaultState)
</code></pre>

<p>因此，我们使用<code>redux-actions</code>来改写我们之前写的reducer</p>

<pre><code class="language-javascript">// reducer/goods.js
import {handleActions} from &#39;redux-actions&#39;;

export const goods = handleActions({
    GET_GOODS: (state, action) =&gt; ({
        ...state,
        data: action.payload
    })
}, {
    data: []
});
</code></pre>

<h3 id="toc_8">然后，对reducer进行合并</h3>

<p>因为在redux中会统一管理一个store，因此，需要将不用的reducer所处理的state进行合并。</p>

<p>redux为我们提供了<code>combineReducers</code>方法。当业务逻辑过多时，我们可以将多个reducer进行组合，生成一个统一的reducer。虽然现在我们只有一个reducer，但是为了拓展性和示范性，在这里还是创建了一个<code>reducer/index.js</code>文件来进行reducer的合并，生成一个<code>rootReducer</code>。</p>

<pre><code class="language-javascript">// reducer/index.js
import {combineReducers} from &#39;redux&#39;;
import {goods} from &#39;./goods&#39;;

export const rootReducer = combineReducers({
    goods
});
</code></pre>

<h3 id="toc_9">之后，将页面组件与数据流相结合</h3>

<p>上面的部分已经将redux中的action与reducer创建完毕了，然而，现在的数据流和我们的组件仍然是处于分离状态的，我们需要让全局的<code>state</code>，即<code>store</code>，的变化能够驱动页面组件的变化，才能完成redux-flow中的最后一环。这就需要将<code>store</code>中的各部分<code>state</code>映射到组件的<code>props</code>上。</p>

<p>解决这个问题就要用到我们之前提到的<code>react-redux</code>工具了。</p>

<p>首先，我们需要基于<code>rootReducer</code>创建一个全局的<code>store</code>。在<code>src</code>目录下新建一个<code>store.js</code>文件，调用redux的<code>createStore</code>方法：</p>

<pre><code class="language-javascript">// store.js
import {createStore} from &#39;redux&#39;;
import {rootReducer} from &#39;./reducer&#39;;
export const store = createStore(rootReducer);
</code></pre>

<p>然后，我们需要让所有的组件都能访问到<code>store</code>。最简单的方式就是使用react-redux<br/>
提供的<code>Provider</code>对整个应用进行包装。这样就可以使所有的子页面、子组件能访问到<code>store</code>。因此需要改写<code>index.js</code>：</p>

<pre><code class="language-javascript">// index.js
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import &#39;./index.css&#39;;
import App from &#39;./App&#39;;
import {Provider} from &#39;react-redux&#39;;
import {store} from &#39;./store&#39;;

ReactDOM.render(
    &lt;Provider store={store}&gt;
        &lt;App /&gt;
    &lt;/Provider&gt;,
document.getElementById(&#39;root&#39;));
</code></pre>

<p>最后，才是进行组件与状态的连接。将store中需要映射的部分connect到我们的组件上。使用其<code>connect</code>方法可以做到这一点：</p>

<pre><code class="language-javascript">connect(mapStateToProps)(component)；
</code></pre>

<p>redux中存在一个全局的store，其中存储了整个应用的状态，对其进行统一管理。<code>connect</code>可以将这个状态中的数据连接到页面组件上。其中，<code>mapStateToProps</code>是store中状态到该组件属性的一个映射方式，<code>component</code>是需要连接的页面组件。通过<code>connect</code>方法，一旦store发生变化，组件也就会相应更新。</p>

<p>我们需要修改原先<code>page/goods.js</code></p>

<pre><code class="language-html">import React, { Component } from &#39;react&#39;;
import {connect} from &#39;react-redux&#39;;

class Goods extends Component {
    render() {
        return (
            &lt;ul className=&quot;goods&quot;&gt;
                {
                    this.props.list.map((ele, idx) =&gt; (
                        &lt;li key={idx} style={{marginBottom: 20, listStyle: &#39;none&#39;}}&gt;
                            &lt;span&gt;{ele.name}&lt;/span&gt; | 
                            &lt;span&gt;￥ {ele.price}&lt;/span&gt; | 
                            &lt;span&gt;剩余 {ele.amount} 件&lt;/span&gt;
                        &lt;/li&gt;
                    ))
                }
            &lt;/ul&gt;
        );
    }
}

const mapStateToProps = (state, ownProps) =&gt; ({
    goods: state.goods.data
});
// export default Goods;
export default connect(mapStateToProps)(Goods);
</code></pre>

<p>此外，也可以为组件中相应的方法映射对应的action的触发：</p>

<pre><code class="language-javascript">const mapDispatchToProps = dispatch =&gt; ({
    onShownClick: () =&gt; dispatch($yourAction)
});
</code></pre>

<h3 id="toc_10">最后，在组件渲染完成后触发整个flow</h3>

<p>如果产生了一个需要状态更新的交互，可以通过在组件中相应部分触发action来实现状态更新--&gt;组件更新。触发方式：</p>

<pre><code class="language-javascript">dispatch($your_action)
</code></pre>

<p><code>connect</code>后的组件，其<code>props</code>里会有一个<code>dispatch</code>的属性，就是个<code>dispatch</code>方法：</p>

<pre><code class="language-javascript">let dispatch = this.props.dispatch;
</code></pre>

<p>因此，最终的<code>page/goods.js</code>组件如下：</p>

<pre><code>import React, { Component } from &#39;react&#39;;
import {connect} from &#39;react-redux&#39;;
import * as actions from &#39;../action/goods&#39;;

const GOODS = [{
    name: &#39;iPhone 7&#39;,
    price: &#39;6,888&#39;,
    amount: 37
}, {
    name: &#39;iPad&#39;,
    price: &#39;3,488&#39;,
    amount: 82
}, {
    name: &#39;MacBook Pro&#39;,
    price: &#39;11,888&#39;,
    amount: 15
}]; 

class Goods extends Component {
    componentDidMount() {
        let dispatch = this.props.dispatch;
        dispatch(actions.getGoods(GOODS));
    }
    render() {
        return (
            &lt;ul className=&quot;goods&quot;&gt;
                {
                    this.props.goods.map((ele, idx) =&gt; (
                        &lt;li key={idx} style={{marginBottom: 20, listStyle: &#39;none&#39;}}&gt;
                            &lt;span&gt;{ele.name}&lt;/span&gt; | 
                            &lt;span&gt;￥ {ele.price}&lt;/span&gt; | 
                            &lt;span&gt;剩余 {ele.amount} 件&lt;/span&gt;
                        &lt;/li&gt;
                    ))
                }
            &lt;/ul&gt;
        );
    }
}

const mapStateToProps = (state, ownProps) =&gt; ({
    goods: state.goods.data
});

export default connect(mapStateToProps)(Goods);
</code></pre>

<p>注意到，组件中数据不再是由<code>App.js</code>中写入的了，而是经过了完整的redux-flow的过程获取并渲染的。注意同时修改<code>App.js</code></p>

<pre><code class="language-javascript">import React, { Component } from &#39;react&#39;;
import Nav from &#39;./component/nav&#39;;
import Welcome from &#39;./page/welcome&#39;;
import Goods from &#39;./page/goods&#39;;
import &#39;./App.css&#39;;

const LIST = [{
    text: &#39;welcome&#39;,
    url: &#39;/&#39;
}, {
    text: &#39;goods&#39;,
    url: &#39;/goods&#39;
}];

class App extends Component {
    render() {
        return (
            &lt;div className=&quot;App&quot;&gt;
                &lt;div className=&quot;nav_bar&quot;&gt;
                    &lt;Nav list={LIST} /&gt;
                &lt;/div&gt;
                &lt;div className=&quot;conent&quot;&gt;
                    &lt;Welcome /&gt;
                    &lt;Goods /&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}

export default App;
</code></pre>

<p>现在访问页面，虽然效果和之前一致，但是其内部构造和原理已经大不相同了。</p>

<h2 id="toc_11">最后一部分：添加路由系统</h2>

<p>单页应用中的重要部分，就是路由系统。由于不同普通的页面跳转刷新，因此单页应用会有一套自己的路由系统需要维护。</p>

<p>我们当然可以手写一个路由系统，但是，为了快速有效地创建于管理我们的应用，我们可以选择一个好用的路由系统。本文选择了react-router 4。这里需要注意，在v4版本里，react-router将WEB部分的路由系统拆分至了<code>react-router-dom</code>，因此需要npm<code>react-router-dom</code></p>

<pre><code class="language-bash">npm i --save react-router-dom
</code></pre>

<p>本例中我们使用react-router中的<code>BrowserRouter</code>组件包裹整个App应用，在其中使用<code>Route</code>组件用于匹配不同的路由时加载不同的页面组件。（也可以使用<code>HashRouter</code>，顾名思义，是使用hash来作为路径）react-router推荐使用<code>BrowserRouter</code>，<code>BrowserRouter</code>需要<code>history</code>相关的API支持。</p>

<p>首先，需要在<code>App.js</code>中添加<code>BrowserRouter</code>组件，并将<code>Route</code>组件放在<code>BrowserRouter</code>内。其中<code>Route</code>组件接收两个属性：<code>path</code>和<code>component</code>，分别是匹配的路径与加载渲染的组件</p>

<pre><code class="language-javascript">// index.js
import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import &#39;./index.css&#39;;
import App from &#39;./App&#39;;
import {Provider} from &#39;react-redux&#39;;
import {store} from &#39;./store&#39;;
import {BrowserRouter, Route} from &#39;react-router-dom&#39;;

ReactDOM.render(
    &lt;Provider store={store}&gt;
        &lt;BrowserRouter&gt;
            &lt;Route path=&#39;/&#39; component={App}/&gt;
        &lt;/BrowserRouter&gt;
    &lt;/Provider&gt;,
document.getElementById(&#39;root&#39;));
</code></pre>

<p>此时我们启动服务器的效果和之前一直。因为此时路由匹配到了<code>path=&#39;/&#39;</code>，因此加载了<code>App</code>组件。</p>

<p>还记得我们在最开始部分创建的<code>Nav</code>导航栏组件么？现在，我们就要实现导航功能：点击对应的导航栏链接，右侧显示不同的区域内容。这需要改造<code>index.js</code>中的content部分：我们为其添加两个<code>Route</code>组件，分别在不同的路径下加载不同的页面组件（<code>welcome</code>与<code>goods</code>）</p>

<pre><code class="language-javascript">// App.js
import React, { Component } from &#39;react&#39;;
import Nav from &#39;./component/nav&#39;;
import Welcome from &#39;./page/welcome&#39;;
import Goods from &#39;./page/goods&#39;;
import &#39;./App.css&#39;;
import {Route} from &#39;react-router-dom&#39;;

const LIST = [{
    text: &#39;welcome&#39;,
    url: &#39;/welcome&#39;
}, {
    text: &#39;goods&#39;,
    url: &#39;/goods&#39;
}];

class App extends Component {
    render() {
        return (
            &lt;div className=&quot;App&quot;&gt;
                &lt;div className=&quot;nav_bar&quot;&gt;
                    &lt;Nav list={LIST} /&gt;
                &lt;/div&gt;
                &lt;div className=&quot;conent&quot;&gt;
                    &lt;Route path=&#39;/welcome&#39; component={Welcome} /&gt;
                    &lt;Route path=&#39;/goods&#39; component={Goods} /&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
}

export default App;
</code></pre>

<p>现在，可以尝试在地址栏输入<code>http://localhost:3000</code>、<code>http://localhost:3000/welcome</code>和<code>http://localhost:3000/goods</code>来查看效果。</p>

<p>当然，实际项目里不可能是通过手动修改地址栏来“跳转”页面。所以需要用到<code>Link</code>这个组件。通过其中的<code>to</code>这个属性来指明“跳转”的地址。这个<code>Link</code>组件我们会添加到<code>Nav</code>组件中</p>

<pre><code>// component/nav/index.js
import React from &#39;react&#39;;
import &#39;./index.css&#39;;
import {Link} from &#39;react-router-dom&#39;;

const Nav = props =&gt; (
    &lt;ul className=&quot;nav&quot;&gt;
        {
            props.list.map((ele, idx) =&gt; (
                &lt;Link to={ele.url} key={idx}&gt;
                    &lt;li&gt;{ele.text}&lt;/li&gt;
                &lt;/Link&gt;
            ))
        }
    &lt;/ul&gt;
);

export default Nav;
</code></pre>

<p>最终页面效果如下：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/6476654-2a910fb0b5ca7659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最终效果图welcome页面"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/6476654-c1e748c23f8d83cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最终效果图goods页面"/></p>

<p>现在在这个demo里，我们点击左侧的导航，右侧内容发生变化，浏览器不会刷新。基于React+Redux+React-router，我们实现了一个最基础版的SPA（单页应用）。</p>

<hr/>

<p><strong><a href="https://github.com/alienzhou/react-redux-demo">点击这里可以下载这个demo。</a></strong></p>

<hr/>

<h2 id="toc_12">额外的部分，异步请求</h2>

<p>如果你还记得在redux数据流部分，是怎么给goods页面传入数据的：<code>dispatch(actions.getGoods(GOODS))</code>，我们直接给<code>getGoods</code>这个<code>action</code>构造器传入<code>GOODS</code>列表，作为加载的数据。但是，在实际的应用场景中，往往，我们会在action中发送ajax请求，从后端获取数据；在等待数据获取的过程中，可能还会有一个loading效果；最后收到了response响应，再渲染响应页面。</p>

<p>基于以上的场景，重新整理一下我们的action内的思路：</p>

<ol>
<li>component渲染完成后，触发一个action，<code>dispatch(actions.getGoods())</code>。这个action并不会带列表的参数，而是向后端请求结果。</li>
<li>在<code>getGoods()</code>这个方法里，主要会做这三件数：首先，触发一个<code>requestGoods</code>的action，用于表示现在正在请求数据；其次，会调用一个叫<code>fetchData()</code>的方法，这个就是向后端请求数据的方法；最后，在拿到数据后，再触发一个<code>receiveGoods</code>的action，用于标识请求完成并带上渲染的数据。</li>
<li>其他部分与之前类似。</li>
</ol>

<p>这里就有一个问题，基于上面的讨论，我们需要<code>actions.getGoods()</code>这个方法返回一个<code>function</code>来实现我们在步骤2里所说的三个功能；然而，目前项目中的<code>dispatch()</code>方法只能接受一个<code>object</code>类型作为参数。所以，我们需要改造<code>dispatch()</code>方法。</p>

<p>改造的手段就是使用redux-thunk这个中间件。可以使action creator返回一个<code>function</code>（而不仅仅是<code>object</code>），并且使得dispatch方法可以接收一个<code>function</code>作为参数，通过这种改造使得action支持异步（或延迟）操作。</p>

<p>那么如何来改造呢？首先为redux加入redux-thunk这个中间件</p>

<pre><code class="language-bash">npm i --save redux-thunk
</code></pre>

<p>然后修改<code>store.js</code></p>

<pre><code class="language-javascript">// store.js
import {createStore, applyMiddleware, compose} from &#39;redux&#39;;
import {rootReducer} from &#39;./reducer&#39;;
import thunk from &#39;redux-thunk&#39;;

const middleware = [thunk];
export const store = createStore(rootReducer, compose(
    applyMiddleware(...middleware)
));
</code></pre>

<p>然后，基于之前的思路，整理action中的代码。在这里，我们使用setTimeout来模拟向后端请求数据：</p>

<pre><code class="language-javascript">// action/goods.js
import {createAction} from &#39;redux-actions&#39;;

const GOODS = [{
    name: &#39;iPhone 7&#39;,
    price: &#39;6,888&#39;,
    amount: 37
}, {
    name: &#39;iPad&#39;,
    price: &#39;3,488&#39;,
    amount: 82
}, {
    name: &#39;MacBook Pro&#39;,
    price: &#39;11,888&#39;,
    amount: 15
}]; 

const requestGoods = createAction(&#39;REQUEST_GOODS&#39;);
const receiveGoods = createAction(&#39;RECEIVE_GOODS&#39;);

const fetchData = () =&gt; {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve(GOODS);
        }, 1500);
    });
};

export const getGoods = () =&gt; async dispatch =&gt; {
    dispatch(requestGoods());
    let goods = await fetchData();
    dispatch(receiveGoods(goods));
};
</code></pre>

<p>相应地修改reducer中的代码</p>

<pre><code class="language-javascript">// reducer/goods.js
import {handleActions} from &#39;redux-actions&#39;;

export const goods = handleActions({
    REQUEST_GOODS: (state, action) =&gt; ({
        ...state,
        isFetching: true
    }),
    RECEIVE_GOODS: (state, action) =&gt; ({
        ...state,
        isFetching: false,
        data: action.payload
    })
}, {
    isFetching: false,
    data: []
});
</code></pre>

<p>可以看到，我们添加了一个<code>isFetching</code>的状态来表示数据是否加载完毕。</p>

<p>最后，还需要更新UI component层</p>

<pre><code>// page/goods.js
import React, { Component } from &#39;react&#39;;
import {connect} from &#39;react-redux&#39;;
import * as actions from &#39;../action/goods&#39;;

class Goods extends Component {
    componentDidMount() {
        let dispatch = this.props.dispatch;
        dispatch(actions.getGoods());
    }
    render() {
        return this.props.isFetching ? (&lt;h1&gt;Loading…&lt;/h1&gt;) : (
            &lt;ul className=&quot;goods&quot;&gt;
                {
                    this.props.goods.map((ele, idx) =&gt; (
                        &lt;li key={idx} style={{marginBottom: 20, listStyle: &#39;none&#39;}}&gt;
                            &lt;span&gt;{ele.name}&lt;/span&gt; | 
                            &lt;span&gt;￥ {ele.price}&lt;/span&gt; | 
                            &lt;span&gt;剩余 {ele.amount} 件&lt;/span&gt;
                        &lt;/li&gt;
                    ))
                }
            &lt;/ul&gt;
        );
    }
}

const mapStateToProps = (state, ownProps) =&gt; ({
    isFetching: state.goods.isFetching,
    goods: state.goods.data
});

export default connect(mapStateToProps)(Goods);
</code></pre>

<p>最终，访问<code>http://localhost:3000/goods</code>页面会有一个大约1.5s的loading效果，然后等“后端”数据返回后渲染出列表。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/6476654-31f02cf83192276e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading效果"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/6476654-c63f5cdf69659c53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="列表加载完毕"/></p>

<h2 id="toc_13">最后的最后，如果你还没有走开</h2>

<p>再介绍一个redux调试神器——<a href="https://github.com/gaearon/redux-devtools">redux-devTools</a>，可以在chrome插件中可以找到</p>

<p><img src="http://upload-images.jianshu.io/upload_images/6476654-2dd97c02d08631d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redux-devTools extension"/></p>

<p>在开发者工具中使用，可以很方便的进行redux的调试</p>

<p><img src="http://upload-images.jianshu.io/upload_images/6476654-a19220d421015fe2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redux-devTools调试界面"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/6476654-2dc20497ac24afce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redux-devTools调试界面"/></p>

<p>当然，需要在代码中进行简单的配置。对<code>store.js</code>进行一些小修改</p>

<pre><code class="language-javascript">import {createStore, applyMiddleware, compose} from &#39;redux&#39;;
import {rootReducer} from &#39;./reducer&#39;;
import thunk from &#39;redux-thunk&#39;;

const middleware = [thunk];
// export const store = createStore(rootReducer, compose(
//     applyMiddleware(...middleware)
// ));
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;
export const store = createStore(rootReducer, composeEnhancers(
    applyMiddleware(...middleware)
));
</code></pre>

<p>以上。</p>

<p>现在，你可以愉快地进行SPA的开发啦！<strong><a href="https://github.com/alienzhou/react-redux-demo">本文中的demo可以点击这里获取</a></strong>。</p>

<hr/>

<h2 id="toc_14">Happy Coding！</h2>

<hr/>


		</div>
	

 
	

  
  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
