<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  【PWA学习与实践】(7)使用Notification API来进行消息提醒 - AlienZHOU's blog
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="AlienZHOU's blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">AlienZHOU's blog</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; AlienZHOU's blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>PWA</label></li>

          
            <li><a title="【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案" href="15288038664515.html">【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案</a></li>
          
            <li><a title="【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync" href="15288038009038.html">【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync</a></li>
          
            <li><a title="【PWA学习与实践】(7)使用Notification API来进行消息提醒" href="15288036503920.html">【PWA学习与实践】(7)使用Notification API来进行消息提醒</a></li>
          
            <li><a title="【PWA学习与实践】(6) 在Chrome中调试你的PWA" href="15288035758780.html">【PWA学习与实践】(6) 在Chrome中调试你的PWA</a></li>
          
            <li><a title="【PWA学习与实践】(5)在Web中进行服务端消息推送" href="15288030176091.html">【PWA学习与实践】(5)在Web中进行服务端消息推送</a></li>
          
            <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
          
            <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
          
            <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
          
            <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
          

      
        <li class="divider"></li>
        <li><label>React</label></li>

          
            <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
          
            <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
          

      
        <li class="divider"></li>
        <li><label>CSS</label></li>

          
            <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
          
            <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
          
            <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
          

      
        <li class="divider"></li>
        <li><label>Server</label></li>

          
            <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
          

      
        <li class="divider"></li>
        <li><label>Automation</label></li>

          
            <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
          

      
        <li class="divider"></li>
        <li><label>FE else</label></li>

          
            <li><a title="各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）" href="15288039493853.html">各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）</a></li>
          
            <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
          
            <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
          
            <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
          

      
        <li class="divider"></li>
        <li><label>Reading</label></li>

          
            <li><a title="推荐阅读 2018.06" href="15288017709756.html">推荐阅读 2018.06</a></li>
          
            <li><a title="推荐阅读 2018.05" href="15287963471356.html">推荐阅读 2018.05</a></li>
          
            <li><a title="推荐阅读 2018.04" href="15283399559020.html">推荐阅读 2018.04</a></li>
          
            <li><a title="推荐阅读 2018.03" href="15282529256902.html">推荐阅读 2018.03</a></li>
          

      
        <li class="divider"></li>
        <li><label>Performace</label></li>

          
            <li><a title="【性能优化实践】优化打包策略提升页面加载速度" href="15288037747207.html">【性能优化实践】优化打包策略提升页面加载速度</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>PWA</span></li>
                        
                          <li><a title="【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案" href="15288038664515.html">【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案</a></li>
                        
                          <li><a title="【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync" href="15288038009038.html">【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync</a></li>
                        
                          <li><a title="【PWA学习与实践】(7)使用Notification API来进行消息提醒" href="15288036503920.html">【PWA学习与实践】(7)使用Notification API来进行消息提醒</a></li>
                        
                          <li><a title="【PWA学习与实践】(6) 在Chrome中调试你的PWA" href="15288035758780.html">【PWA学习与实践】(6) 在Chrome中调试你的PWA</a></li>
                        
                          <li><a title="【PWA学习与实践】(5)在Web中进行服务端消息推送" href="15288030176091.html">【PWA学习与实践】(5)在Web中进行服务端消息推送</a></li>
                        
                          <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
                        
                          <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
                        
                          <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
                        
                          <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
                        

                    
                      <li class="side-title"><span>React</span></li>
                        
                          <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
                        
                          <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
                        

                    
                      <li class="side-title"><span>CSS</span></li>
                        
                          <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
                        
                          <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
                        
                          <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
                        

                    
                      <li class="side-title"><span>Server</span></li>
                        
                          <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
                        

                    
                      <li class="side-title"><span>Automation</span></li>
                        
                          <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
                        

                    
                      <li class="side-title"><span>FE else</span></li>
                        
                          <li><a title="各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）" href="15288039493853.html">各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）</a></li>
                        
                          <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
                        
                          <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
                        
                          <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
                        

                    
                      <li class="side-title"><span>Reading</span></li>
                        
                          <li><a title="推荐阅读 2018.06" href="15288017709756.html">推荐阅读 2018.06</a></li>
                        
                          <li><a title="推荐阅读 2018.05" href="15287963471356.html">推荐阅读 2018.05</a></li>
                        
                          <li><a title="推荐阅读 2018.04" href="15283399559020.html">推荐阅读 2018.04</a></li>
                        
                          <li><a title="推荐阅读 2018.03" href="15282529256902.html">推荐阅读 2018.03</a></li>
                        

                    
                      <li class="side-title"><span>Performace</span></li>
                        
                          <li><a title="【性能优化实践】优化打包策略提升页面加载速度" href="15288037747207.html">【性能优化实践】优化打包策略提升页面加载速度</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>【PWA学习与实践】(7)使用Notification API来进行消息提醒</h1>

<p>本文是《PWA学习与实践》系列的第七篇文章。</p>

<p>PWA作为时下最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。</p>

<p>本系列文章《PWA学习与实践》会逐步拆解PWA背后的各项技术，通过实例代码来讲解这些技术的应用方式。也正是因为PWA中技术点众多、知识细碎，因此我在学习过程中，进行了整理，并产出了《PWA学习与实践》系列文章，希望能带大家全面了解PWA中的各项技术。对PWA感兴趣的朋友欢迎关注。</p>

<blockquote>
<p>本文中的代码可以在<a href="https://github.com/alienzhou/learning-pwa/tree/notification">learning-pwa的notification分支</a>上找到（<code>git clone</code>后注意切换到notification分支）。</p>
</blockquote>

<h2 id="toc_0">1. 引言</h2>

<p>在第五篇文章《Web中进行服务端消息推送》中，我介绍了如何使用Push API进行服务端消息推送。提到Push就不得不说与其联系紧密的另一个API——Notification API。它让我们可以在“网站外”显示消息提示：</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631a562ba773ddd?w=1275&amp;h=762&amp;f=gif&amp;s=384884" alt=""/></p>

<p>即使当你切换到其他Tab，也可以通过提醒交互来快速让用户回到你的网站；甚至当用户离开当前网站，仍然可以收到系统的提醒消息，并且可以通过消息提醒快速打开你的网站。</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631b52052cccb59?w=1270&amp;h=676&amp;f=gif&amp;s=2317289" alt=""/></p>

<p>Notification的功能本身与Push并不耦合，你完全可以只使用Notification API或者Push API来构建Web App的某些功能。因此，本文会先介绍如何使用Notification API。然后，作为Notification的“黄金搭档”，本文还会介绍如何组合使用Push &amp; Notification（消息推送与提醒）。</p>

<h2 id="toc_1">2. 使用Notification API</h2>

<p>在这第二节里，我们先来了解如何独立使用Notification功能。相较于第五篇中的Push功能，Notification API更加简洁易懂。</p>

<h3 id="toc_2">2.1. 获取提醒权限</h3>

<p>首先，进行调用消息提醒API需要获得用户的授权。</p>

<p>在调用Notification相关API之前，需要先使用<code>Notification</code>对象上的静态方法<code>Notification.requestPermission()</code>来获取授权。由于<code>Notification.requestPermission()</code>在某些版本浏览器中会接收一个回调函数（<code>Notification.requestPermission(callback)</code>）作为参数，而在另一些浏览器版本中会返回一个promise，因此将该方法进行包装，统一为promise调用：</p>

<pre><code class="language-javascript">// index.js
function askPermission() {
    return new Promise(function (resolve, reject) {
        var permissionResult = Notification.requestPermission(function (result) {
            resolve(result);
        });
  
        if (permissionResult) {
            permissionResult.then(resolve, reject);
        }
    }).then(function (permissionResult) {
        if (permissionResult !== &#39;granted&#39;) {
            throw new Error(&#39;We weren\&#39;t granted permission.&#39;);
        }
    });
}


registerServiceWorker(&#39;./sw.js&#39;).then(function (registration) {
    return Promise.all([
        registration,
        askPermission()
    ])
 })
</code></pre>

<p>我们创建了一个<code>askPermission()</code>方法来统一<code>Notification.requestPermission()</code>的调用形式，并在Service Worker注册完成后调用该方法。调用<code>Notification.requestPermission()</code>获取的<code>permissionResult</code>可能的值为：</p>

<ul>
<li>denied：用户拒绝了通知的显示</li>
<li>granted：用户允许了通知的显示</li>
<li>default：因为不知道用户的选择，所以浏览器的行为与denied时相同</li>
</ul>

<p>chrome中，可以在<code>chrome://settings/content/notifications</code>里进行通知的设置与管理。</p>

<h3 id="toc_3">2.2. 设置你的提醒内容</h3>

<p>获取用户授权后，我们就可以通过<code>registration.showNotification()</code>方法进行消息提醒了。</p>

<p>当我们注册完Service Worker后，<code>then</code>方法的回调函数会接收一个<code>registration</code>参数，通过调用其上的<code>showNotification()</code>方法即可触发提醒：</p>

<pre><code class="language-javascript">// index.js
registerServiceWorker(&#39;./sw.js&#39;).then(function (registration) {
    return Promise.all([
        registration,
        askPermission()
    ])
}).then(function (result) {
    var registration = result[0];
    /* ===== 添加提醒功能 ====== */
    document.querySelector(&#39;#js-notification-btn&#39;).addEventListener(&#39;click&#39;, function () {
        var title = &#39;PWA即学即用&#39;;
        var options = {
            body: &#39;邀请你一起学习&#39;,
            icon: &#39;/img/icons/book-128.png&#39;,
            actions: [{
                action: &#39;show-book&#39;,
                title: &#39;去看看&#39;
            }, {
                action: &#39;contact-me&#39;,
                title: &#39;联系我&#39;
            }],
            tag: &#39;pwa-starter&#39;,
            renotify: true
        };
        registration.showNotification(title, options);
    });
    /* ======================= */
})
</code></pre>

<p>上面这段代码为页面上的button添加了一个click事件监听：当点击后，调用<code>registration.showNotification()</code>方法来显示消息提醒，该方法接收两个参数：<code>title</code>与<code>option</code>。<code>title</code>用来设置该提醒的主标题，<code>option</code>中则包含了一些其他设置。</p>

<ul>
<li>body：提醒的内容</li>
<li>icon：提醒的图标</li>
<li>actions：提醒可以包含一些自定义操作</li>
<li>tag：相当于是ID，通过该ID标识可以操作特定的notification</li>
<li>renotify：是否允许重复提醒，默认为false。当不允许重复提醒时，同一个tag的notification只会显示一次</li>
</ul>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631a6c6007ffec9?w=800&amp;h=300&amp;f=jpeg&amp;s=114296" alt=""/></p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631a6f12cc17f0c?w=800&amp;h=161&amp;f=jpeg&amp;s=66563" alt=""/></p>

<blockquote>
<p>注意，由于不同浏览器中，对于<code>option</code>属性的支持情况并不相同。部分属性在一些浏览器中并不支持。</p>
</blockquote>

<h3 id="toc_4">2.3. 捕获用户的点击</h3>

<p>在上一部分中，我们已经为Web App添加了提醒功能。点击页面中的“提醒”按钮，系统就会弹出提醒框，并展示相关提醒消息。</p>

<p>然而更多的时候，我们并不仅仅希望只展示有限的信息，更希望能引导用户进行交互。例如推荐一本新书，让用户点击阅读或购买。在上一部分我们设置的提醒框中，包含了“去看看”和“联系我”两个按钮选项，那么怎么做才能捕获用户的点击操作，并且知道用户点击了哪个呢？这一小节，就会告诉你如何实现。</p>

<p>还记的上一部分里我们定义的actions么？</p>

<pre><code class="language-javascript">…
actions: [{
    action: &#39;show-book&#39;,
    title: &#39;去看看&#39;
    }, {
    action: &#39;contact-me&#39;,
    title: &#39;联系我&#39;
}]
…
</code></pre>

<p>为了能够响应用户对于提醒框的点击事件，我们需要在Service Worker中监听<code>notificationclick</code>事件。在该事件的回调函数中我们可以获取点击的相关信息：</p>

<pre><code class="language-javascript">// sw.js
self.addEventListener(&#39;notificationclick&#39;, function (e) {
    var action = e.action;
    console.log(`action tag: ${e.notification.tag}`, `action: ${action}`);
    
    switch (action) {
        case &#39;show-book&#39;:
            console.log(&#39;show-book&#39;);
            break;
        case &#39;contact-me&#39;:
            console.log(&#39;contact-me&#39;);
            break;
        default:
            console.log(`未处理的action: ${e.action}`);
            action = &#39;default&#39;;
            break;
    }
    e.notification.close();
});
</code></pre>

<p><code>e.action</code>获取的值，就是我们在<code>showNotification()</code>中定义的actions里的action。因此，通过<code>e.action</code>就可以知道用户点击了哪一个操作选项。注意，当用户点击提醒本身时，也会触发<code>notificationclick</code>，但是不包含任何action值，所以在代码中将其置于default默认操作中。</p>

<p>现在试一下，我们就可以捕获用户对于不同选项的点击了。点击后在Console中会有不同的输出。</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631a855e6ac1712?w=1120&amp;h=188&amp;f=png&amp;s=52210" alt=""/></p>

<h3 id="toc_5">2.4. Service Worker与client通信</h3>

<p>到目前为止，我们已经可以顺利得给用户展示提醒，并且在用户操作提醒后准确捕获到用户的操作。然而，还缺最重要的一步——针对不同的操作，触发不同的交互。例如，<br/>
- 点击提醒本身会弹出书籍简介；<br/>
- 点击“看一看”会给用户展示本书的详情；<br/>
- 点击“联系我”会向应用管理者发邮件等等。</p>

<p>这里有个很重要的地方：我们在Service Worker中捕获用户操作，但是需要在client（这里的client是指前端页面的脚本环境）中触发相应操作（调用页面方法/进行页面跳转…）。因此，这就需要让Service Worker与client进行通信。通信包括下面两个部分：</p>

<ol>
<li>在Service Worker中使用Worker的<code>postMessage()</code>方法来通知client：</li>
</ol>

<pre><code class="language-javascript">// sw.js
self.addEventListener(&#39;notificationclick&#39;, function (e) {
    …… // 略去上一节内容
    
    e.waitUntil(
        // 获取所有clients
        self.clients.matchAll().then(function (clients) {
            if (!clients || clients.length === 0) {
                return;
            }
            clients.forEach(function (client) {
                // 使用postMessage进行通信
                client.postMessage(action);
            });
        })
    );
});
</code></pre>

<ol>
<li>在client中监听<code>message</code>事件，判断<code>data</code>，进行不同的操作：</li>
</ol>

<pre><code class="language-javascript">// index.js
navigator.serviceWorker.addEventListener(&#39;message&#39;, function (e) {
    var action = e.data;
    console.log(`receive post-message from sw, action is &#39;${e.data}&#39;`);
    switch (action) {
        case &#39;show-book&#39;:
            location.href = &#39;https://book.douban.com/subject/20515024/&#39;;
            break;
        case &#39;contact-me&#39;:
            location.href = &#39;mailto:someone@sample.com&#39;;
            break;
        default:
            document.querySelector(&#39;.panel&#39;).classList.add(&#39;show&#39;);
            break;
    }
});
</code></pre>

<p>当用户点击提醒后，我们在<code>notificationclick</code>监听中，将action通过<code>postMessage()</code>通信给client；然后在client中监听<code>message</code>事件，基于action（<code>e.data</code>）来进行不同的操作（跳转到图书详情页/发送邮件/显示简介面板）。</p>

<p>至此，一个比较简单与完整的消息提醒（Notification）功能就完成了。</p>

<p>然而目前的消息提醒还存在一定的局限性。例如，只有在用户访问网站期间才能有机会触发提醒。正如本文一开始所说，Push &amp; Notification的结合将会帮助我们构筑一个强大推送与提醒功能。下面就来看下它们的简单结合。</p>

<h2 id="toc_6">3. 消息推送与提醒</h2>

<p>在第五篇《Web中进行服务端消息推送》最后，我们通过监听<code>push</code>事件来处理服务端推送：</p>

<pre><code class="language-javascript">// sw.js
self.addEventListener(&#39;push&#39;, function (e) {
    var data = e.data;
    if (e.data) {
        data = data.json();
        console.log(&#39;push的数据为：&#39;, data);
        self.registration.showNotification(data.text);        
    } 
    else {
        console.log(&#39;push没有任何数据&#39;);
    }
});
</code></pre>

<p>简单修改以上代码，与我们本文中的提醒功能相结合：</p>

<pre><code class="language-javascript">// sw.js
self.addEventListener(&#39;push&#39;, function (e) {
    var data = e.data;
    if (e.data) {
        data = data.json();
        console.log(&#39;push的数据为：&#39;, data);
        var title = &#39;PWA即学即用&#39;;
        var options = {
            body: data,
            icon: &#39;/img/icons/book-128.png&#39;,
            image: &#39;/img/icons/book-521.png&#39;, // no effect
            actions: [{
                action: &#39;show-book&#39;,
                title: &#39;去看看&#39;
            }, {
                action: &#39;contact-me&#39;,
                title: &#39;联系我&#39;
            }],
            tag: &#39;pwa-starter&#39;,
            renotify: true
        };
        self.registration.showNotification(title, options);        
    } 
    else {
        console.log(&#39;push没有任何数据&#39;);
    }
});
</code></pre>

<p>使用Push来向用户推送信息，并在Service Worker中直接调用Notification API来展示该信息的提醒框。这样，即使是在用户关闭该Web App时，依然可以收到提醒，类似于Native中的消息推送与提醒。</p>

<p>我们还可以将这个功能再丰富一些。由于用户在关闭该网站时仍然可以收到提醒，因此加入一些更强大功能：<br/>
- 当用户切换到其他Tab时，点击提醒会立刻回到网站的tab；<br/>
- 当用户未打开该网站时，点击提醒可以直接打开网站。</p>

<pre><code class="language-javascript">// sw.js
self.addEventListener(&#39;notificationclick&#39;, function (e) {
    var action = e.action;
    console.log(`action tag: ${e.notification.tag}`, `action: ${action}`);
    
    switch (action) {
        case &#39;show-book&#39;:
            console.log(&#39;show-book&#39;);
            break;
        case &#39;contact-me&#39;:
            console.log(&#39;contact-me&#39;);
            break;
        default:
            console.log(`未处理的action: ${e.action}`);
            action = &#39;default&#39;;
            break;
    }
    e.notification.close();

    e.waitUntil(
        // 获取所有clients
        self.clients.matchAll().then(function (clients) {
            if (!clients || clients.length === 0) {
                // 当不存在client时，打开该网站
                self.clients.openWindow &amp;&amp; self.clients.openWindow(&#39;http://127.0.0.1:8085&#39;);
                return;
            }
            // 切换到该站点的tab
            clients[0].focus &amp;&amp; clients[0].focus();
            clients.forEach(function (client) {
                // 使用postMessage进行通信
                client.postMessage(action);
            });
        })
    );
});
</code></pre>

<p>注意这两行代码，第一行会在网站关闭时打开该网站，第二行会在存在tab时自动切换到网站的tab。</p>

<pre><code class="language-javascript">self.clients.openWindow &amp;&amp; self.clients.openWindow(&#39;http://127.0.0.1:8085&#39;);

clients[0].focus &amp;&amp; clients[0].focus();
</code></pre>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631b52052cccb59?w=1270&amp;h=676&amp;f=gif&amp;s=2317289" alt=""/></p>

<h2 id="toc_7">4. MacOS Safari中的Web Notification</h2>

<p>看一下<a href="https://caniuse.com/#search=notification">Web Notification的兼容性</a>：</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631afa349ff2f0c?w=2344&amp;h=918&amp;f=png&amp;s=222023" alt=""/></p>

<p>目前移动端浏览器普遍还不支持该特性。但是在Mac OS上的safari里面是支持该特性的，不过其调用方式与上文代码有些不太一样。在safari中使用Web Notification不是调用<code>registration.showNotification()</code>方法，而是需要创建一个Notification对象。</p>

<pre><code class="language-javascript">// index.js
……
document.querySelector(&#39;#js-notification-btn&#39;).addEventListener(&#39;click&#39;, function () {
    var title = &#39;PWA即学即用&#39;;
    var options = {
        body: &#39;邀请你一起学习&#39;,
        icon: &#39;/img/icons/book-128.png&#39;,
        actions: [{
            action: &#39;show-book&#39;,
            title: &#39;去看看&#39;
        }, {
            action: &#39;contact-me&#39;,
            title: &#39;联系我&#39;
        }],
        tag: &#39;pwa-starter&#39;,
        renotify: true
    };
    // registration.showNotification(title, options);

    // 使用Notification构造函数创建提醒框
    // 而非registration.showNotification()方法
    var notification = new Notification(title, options);
});
……
</code></pre>

<p>Notification对象继承自EventTarget接口，因此在safari中需要通过添加click事件的监听来触发提醒框的交互操作：</p>

<pre><code class="language-javascript">// index.js
notification.addEventListener(&#39;click&#39;, function (e) {
    document.querySelector(&#39;.panel&#39;).classList.add(&#39;show&#39;);
});
</code></pre>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631b1ef1e592c36?w=677&amp;h=369&amp;f=gif&amp;s=308375" alt=""/></p>

<p>该功能示例可以在<a href="https://github.com/alienzhou/learning-pwa/tree/notify4safari">learn-pwa/notify4safari</a>中找到。</p>

<h2 id="toc_8">5. 写在最后</h2>

<p>Web Notification是一个非常强大的API，尤其在和Push结合后，为WebApp带来了类似Native的丰富能力。</p>

<p>本文中所有的代码示例均可以在<a href="https://github.com/alienzhou/learning-pwa/tree/notification">learn-pwa/notification</a>上找到。</p>

<p>如果你喜欢或想要了解更多的PWA相关知识，欢迎关注我，关注<a href="https://juejin.im/user/59ad5377518825244d206d2d/posts">《PWA学习与实践》</a>系列文章。我会总结整理自己学习PWA过程的遇到的疑问与技术点，并通过实际代码和大家一起实践。</p>

<p>到目前为止，我们已经学习了Manifest、离线缓存、消息推送、消息提醒、Debug等一些基础知识。在下一篇文章里，我们会继续了解与学习PWA中的一个重要功能——后台同步。</p>

<h2 id="toc_9">参考资料</h2>

<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/notification">MDN: notification</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification">MDN: ServiceWorkerRegistration.showNotification()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowClient">MDN: WindowClient</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Clients">MDN: Clients</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2013/614/">WWDC2013</a></li>
</ul>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="15288037747207.html"  title="Previous Post: 【性能优化实践】优化打包策略提升页面加载速度">&laquo; 【性能优化实践】优化打包策略提升页面加载速度</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="15288035758780.html" 
	        title="Next Post: 【PWA学习与实践】(6) 在Chrome中调试你的PWA">【PWA学习与实践】(6) 在Chrome中调试你的PWA &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '15288036503920.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
