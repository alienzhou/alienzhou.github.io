<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  【webpack进阶】前端运行时的模块化设计与实现 - AlienZHOU's blog
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="AlienZHOU's blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">AlienZHOU's blog</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; AlienZHOU's blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>PWA</label></li>

          
            <li><a title="【PWA学习与实践】(10)使用Resource Hint提升页面加载性能与体验" href="15354508213008.html">【PWA学习与实践】(10)使用Resource Hint提升页面加载性能与体验</a></li>
          
            <li><a title="【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案" href="15288038664515.html">【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案</a></li>
          
            <li><a title="【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync" href="15288038009038.html">【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync</a></li>
          
            <li><a title="【PWA学习与实践】(7)使用Notification API来进行消息提醒" href="15288036503920.html">【PWA学习与实践】(7)使用Notification API来进行消息提醒</a></li>
          
            <li><a title="【PWA学习与实践】(6) 在Chrome中调试你的PWA" href="15288035758780.html">【PWA学习与实践】(6) 在Chrome中调试你的PWA</a></li>
          
            <li><a title="【PWA学习与实践】(5)在Web中进行服务端消息推送" href="15288030176091.html">【PWA学习与实践】(5)在Web中进行服务端消息推送</a></li>
          
            <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
          
            <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
          
            <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
          
            <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
          

      
        <li class="divider"></li>
        <li><label>React</label></li>

          
            <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
          
            <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
          

      
        <li class="divider"></li>
        <li><label>CSS</label></li>

          
            <li><a title="CSS布局学习指南[译]" href="15301745888974.html">CSS布局学习指南[译]</a></li>
          
            <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
          
            <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
          
            <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
          

      
        <li class="divider"></li>
        <li><label>Server</label></li>

          
            <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
          

      
        <li class="divider"></li>
        <li><label>Automation</label></li>

          
            <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
          

      
        <li class="divider"></li>
        <li><label>FE else</label></li>

          
            <li><a title="各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）" href="15288039493853.html">各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）</a></li>
          
            <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
          
            <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
          
            <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
          

      
        <li class="divider"></li>
        <li><label>Reading</label></li>

          
            <li><a title="推荐阅读 2018.08" href="15333560595579.html">推荐阅读 2018.08</a></li>
          
            <li><a title="推荐阅读 2018.07" href="15307688152882.html">推荐阅读 2018.07</a></li>
          
            <li><a title="推荐阅读 2018.06" href="15288017709756.html">推荐阅读 2018.06</a></li>
          
            <li><a title="推荐阅读 2018.05" href="15287963471356.html">推荐阅读 2018.05</a></li>
          
            <li><a title="推荐阅读 2018.04" href="15283399559020.html">推荐阅读 2018.04</a></li>
          
            <li><a title="推荐阅读 2018.03" href="15282529256902.html">推荐阅读 2018.03</a></li>
          

      
        <li class="divider"></li>
        <li><label>Performace</label></li>

          
            <li><a title="【性能优化实践】优化打包策略提升页面加载速度" href="15288037747207.html">【性能优化实践】优化打包策略提升页面加载速度</a></li>
          

      
        <li class="divider"></li>
        <li><label>webpack</label></li>

          
            <li><a title="【webpack进阶】使用babel避免webpack编译运行时模块依赖" href="15354509456422.html">【webpack进阶】使用babel避免webpack编译运行时模块依赖</a></li>
          
            <li><a title="【webpack进阶】前端运行时的模块化设计与实现" href="15353386669734.html">【webpack进阶】前端运行时的模块化设计与实现</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>PWA</span></li>
                        
                          <li><a title="【PWA学习与实践】(10)使用Resource Hint提升页面加载性能与体验" href="15354508213008.html">【PWA学习与实践】(10)使用Resource Hint提升页面加载性能与体验</a></li>
                        
                          <li><a title="【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案" href="15288038664515.html">【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案</a></li>
                        
                          <li><a title="【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync" href="15288038009038.html">【PWA学习与实践】(8)使用Service Worker进行后台同步 - Background Sync</a></li>
                        
                          <li><a title="【PWA学习与实践】(7)使用Notification API来进行消息提醒" href="15288036503920.html">【PWA学习与实践】(7)使用Notification API来进行消息提醒</a></li>
                        
                          <li><a title="【PWA学习与实践】(6) 在Chrome中调试你的PWA" href="15288035758780.html">【PWA学习与实践】(6) 在Chrome中调试你的PWA</a></li>
                        
                          <li><a title="【PWA学习与实践】(5)在Web中进行服务端消息推送" href="15288030176091.html">【PWA学习与实践】(5)在Web中进行服务端消息推送</a></li>
                        
                          <li><a title="【PWA学习与实践】(4) 解决FireBase login验证失败问题" href="15235166926023.html">【PWA学习与实践】(4) 解决FireBase login验证失败问题</a></li>
                        
                          <li><a title="【PWA学习与实践】(3) 让你的WebApp离线可用" href="15235151669706.html">【PWA学习与实践】(3) 让你的WebApp离线可用</a></li>
                        
                          <li><a title="【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”" href="15235140795593.html">【PWA学习与实践】(2) 使用Manifest，让你的WebApp更“Native”</a></li>
                        
                          <li><a title="【PWA学习与实践】(1) 2018，开始你的PWA学习之旅" href="15235138633619.html">【PWA学习与实践】(1) 2018，开始你的PWA学习之旅</a></li>
                        

                    
                      <li class="side-title"><span>React</span></li>
                        
                          <li><a title="基于react技术栈的单页应用(SPA)搭建_快速入门实践" href="15236392559880.html">基于react技术栈的单页应用(SPA)搭建_快速入门实践</a></li>
                        
                          <li><a title="在react-router4中进行代码拆分（基于webpack）" href="15235187668595.html">在react-router4中进行代码拆分（基于webpack）</a></li>
                        

                    
                      <li class="side-title"><span>CSS</span></li>
                        
                          <li><a title="CSS布局学习指南[译]" href="15301745888974.html">CSS布局学习指南[译]</a></li>
                        
                          <li><a title="【CSS模块化】(3) 使用💅styled-components来优化react组件开发" href="15236398426783.html">【CSS模块化】(3) 使用💅styled-components来优化react组件开发</a></li>
                        
                          <li><a title="【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS" href="15236396803035.html">【CSS模块化】(2) BEM命名方法论——使用BEM-constructor构建CSS</a></li>
                        
                          <li><a title="【CSS模块化】(1) webpack之Local Scope" href="15236395841604.html">【CSS模块化】(1) webpack之Local Scope</a></li>
                        

                    
                      <li class="side-title"><span>Server</span></li>
                        
                          <li><a title="【MongoDB高可用】复制集Replica Set使用简介" href="15236400113573.html">【MongoDB高可用】复制集Replica Set使用简介</a></li>
                        

                    
                      <li class="side-title"><span>Automation</span></li>
                        
                          <li><a title="Gulp.js实践详解__基于Gulp的多页面应用实践指南" href="15236401468681.html">Gulp.js实践详解__基于Gulp的多页面应用实践指南</a></li>
                        

                    
                      <li class="side-title"><span>FE else</span></li>
                        
                          <li><a title="各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）" href="15288039493853.html">各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）</a></li>
                        
                          <li><a title="浏览器同源策略与ajax跨域方法汇总" href="15236404711802.html">浏览器同源策略与ajax跨域方法汇总</a></li>
                        
                          <li><a title="JavaScript异步编程__“回调地狱”的一些解决方案" href="15236403350295.html">JavaScript异步编程__“回调地狱”的一些解决方案</a></li>
                        
                          <li><a title="js控制input框内光标位置（setSelectionRange详解）" href="15236405992551.html">js控制input框内光标位置（setSelectionRange详解）</a></li>
                        

                    
                      <li class="side-title"><span>Reading</span></li>
                        
                          <li><a title="推荐阅读 2018.08" href="15333560595579.html">推荐阅读 2018.08</a></li>
                        
                          <li><a title="推荐阅读 2018.07" href="15307688152882.html">推荐阅读 2018.07</a></li>
                        
                          <li><a title="推荐阅读 2018.06" href="15288017709756.html">推荐阅读 2018.06</a></li>
                        
                          <li><a title="推荐阅读 2018.05" href="15287963471356.html">推荐阅读 2018.05</a></li>
                        
                          <li><a title="推荐阅读 2018.04" href="15283399559020.html">推荐阅读 2018.04</a></li>
                        
                          <li><a title="推荐阅读 2018.03" href="15282529256902.html">推荐阅读 2018.03</a></li>
                        

                    
                      <li class="side-title"><span>Performace</span></li>
                        
                          <li><a title="【性能优化实践】优化打包策略提升页面加载速度" href="15288037747207.html">【性能优化实践】优化打包策略提升页面加载速度</a></li>
                        

                    
                      <li class="side-title"><span>webpack</span></li>
                        
                          <li><a title="【webpack进阶】使用babel避免webpack编译运行时模块依赖" href="15354509456422.html">【webpack进阶】使用babel避免webpack编译运行时模块依赖</a></li>
                        
                          <li><a title="【webpack进阶】前端运行时的模块化设计与实现" href="15353386669734.html">【webpack进阶】前端运行时的模块化设计与实现</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>【webpack进阶】前端运行时的模块化设计与实现</h1>

<blockquote>
<p>你真的了解前端模块化么？</p>
</blockquote>

<h2 id="toc_0">告别「webpack配置工程师」</h2>

<p>webpack是一个强大而复杂的前端自动化工具。其中一个特点就是配置复杂，这也使得「webpack配置工程师」这种戏谑的称呼开始流行🤷但是，难道你真的只满足于玩转webpack配置么？</p>

<p>显然不是。在学习如何使用webpack之外，我们更需要深入webpack内部，探索各部分的设计与实现。万变不离其宗，即使有一天webpack“过气”了，但它的某些设计与实现却仍会有学习价值与借鉴意义。因此，在学习webpack过程中，我会总结一系列【webpack进阶】的文章和大家分享。</p>

<p>欢迎感兴趣的同学多多交流与关注！</p>

<h2 id="toc_1">1. 引言</h2>

<p>下面进入正题。一直以来，在前端领域，开发人员日益增长的语言能力需求和落后的JavaScript规范形成了一大矛盾。例如，我们会用babel来进行ES6到ES5的语法转换，会使用各种polyfill来兼容老式上的新特性……而我们本文的主角 —— 模块化也是如此。</p>

<p>由于JavaScript在设计之初就没有考虑这一点，加之模块化规范的迟到，导致社区中涌现出一系列前端运行时的模块化方案，例如RequireJS、seaJS等。以及与之对应的编译期模块依赖解决方案，例如browserify、rollup和本文的主角webpack。</p>

<p>但是我们要知道，<code>&lt;script type=&quot;module&quot;&gt;</code>还存在一定的兼容性与使用问题。</p>

<p><img src="https://user-gold-cdn.xitu.io/2018/8/27/1657be864c854472?w=2348&amp;h=1252&amp;f=png&amp;s=273693" alt=""/></p>

<p>在更通用的范围内来讲，浏览器原生实际是不支持所谓的CommonJS或ESM模块化规范的。那么webpack是如何在打包出的代码中实现模块化的呢？</p>

<h2 id="toc_2">2. NodeJS中的模块化</h2>

<p>在探究webpack打包后代码的模块化实现前，我们先来看一下Node中的模块化。</p>

<p>NodeJS（以下简称为Node）在模块化上基本是遵循的CommonJS规范，而webpack打包出来的代码所实现模块化的方式，也类似于CommonJS。因此，我们先以熟悉的Node（这里主要参考Node v10）作为引子，简单介绍它的模块化实现，帮助我们接下来理解webpack的实现。</p>

<p>Node中的模块引入会经历下面几个步骤：</p>

<ol>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ol>

<p>在Node中，模块以文件维度存在，并且在编译后缓存于内存中，通过<code>require.cache</code>可以查看模块缓存情况。在模块中添加<code>console.log(require.cache)</code>查看输出如下：</p>

<pre><code class="language-JavaScript">{ &#39;/Users/alienzhou/programming/gitrepo/test.js&#39;:
   Module {
     id: &#39;.&#39;,
     exports: {},
     parent: null,
     filename: &#39;/Users/alienzhou/programming/gitrepo/test.js&#39;,
     loaded: false,
     children: [],
     paths:
      [ &#39;/Users/alienzhou/programming/gitrepo/node_modules&#39;,
        &#39;/Users/alienzhou/programming/node_modules&#39;,
        &#39;/Users/alienzhou/node_modules&#39;,
        &#39;/Users/node_modules&#39;,
        &#39;/node_modules&#39; ] } }
</code></pre>

<p>上面就是模块对象的数据结构，也可以在<a href="https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L102-L110">Node源码</a>中找到Module类的构造方法。其中<code>exports</code>属性非常重要，它就是模块的导出对象。因此，下面这行语句</p>

<pre><code class="language-JavaScript">var test = require(&#39;./test.js&#39;);
</code></pre>

<p>其实就是把<code>test.js</code>模块的<code>exports</code>属性赋值给<code>test</code>变量。</p>

<p>也许你还会好奇，当我们写一个Node(JavaScript)模块时，模块里的<code>module</code>、<code>require</code>、<code>__filename</code>等这些变量是哪来的？如果你看过<a href="https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L124-L131">Node loader.js 部分源码</a>，应该就大致能理解：</p>

<pre><code class="language-JavaScript">Module.wrap = function(script) {
  return Module.wrapper[0] + script + Module.wrapper[1];
};

Module.wrapper = [
  &#39;(function (exports, require, module, __filename, __dirname) { &#39;,
  &#39;\n});&#39;
];
</code></pre>

<p>Node会自动将每个模块进行包装（wrap），将其变为一个function。例如模块test.js原本为：</p>

<pre><code class="language-JavaScript">console.log(require.cache);
module.exports = &#39;test&#39;;
</code></pre>

<p>包装后大致会变为：</p>

<pre><code class="language-JavaScript">(function (exports, require, module, __filename, __dirname) {
    console.log(require.cache);
    module.exports = &#39;test&#39;;
});
</code></pre>

<p>这下你应该明白<code>module</code>、<code>require</code>、<code>__filename</code>这些变量都是哪来的了吧 —— 它们会被作为function的参数在模块编译执行时注入进来。以一个扩展名为<code>.js</code>的模块为例，当你<code>require</code>它时，一个完整的方法调用大致包括下面几个过程：</p>

<pre><code class="language-flow">st=&gt;start: require()引入模块
op1=&gt;operation: 调用._load()加载模块
op2=&gt;operation: new Module(filename, parent)创建模块对象
op3=&gt;operation: 将模块对象存入缓存
op4=&gt;operation: 根据文件类型调用Module._extensions
op5=&gt;operation: 调用.compile()编译执行js模块
cond=&gt;condition: Module._cache是否无缓存
e=&gt;end: 返回module.exports结果
st-&gt;op1-&gt;cond
cond(yes)-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;e
cond(no)-&gt;e
</code></pre>

<p>在<a href="https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L685-L691">Node源码</a>中能看到，模块执行时，包装定义的几个变量被注入了：</p>

<pre><code class="language-JavaScript">if (inspectorWrapper) {
    result = inspectorWrapper(compiledWrapper, this.exports, this.exports,
                              require, this, filename, dirname);

} else {
    result = compiledWrapper.call(this.exports, this.exports, require, this,
                                  filename, dirname);
}

</code></pre>

<blockquote>
<p>题外话，从这里你也可以看出，在模块内使用<code>module.exports</code>与<code>exports</code>的区别</p>
</blockquote>

<h2 id="toc_3">3. webpack实现的前端模块化</h2>

<p>之所以在介绍「webpack是如何在打包出的代码中实现模块化」之前，先用一定篇幅介绍了Node中的模块化，是因为两者在同步依赖的设计与实现上有异曲同工之处。理解Node的模块化对学习webpack很有帮助。当然，由于运行环境的不同（webpack打包出的代码运行在客户端，而Node是在服务端），实现上也有一定的差异。</p>

<p>下面就来看一下，webpack是如何在打包出的代码中实现前端（客户端）模块化的。</p>

<h3 id="toc_4">3.1. 模块对象</h3>

<p>和Node的模块化实现类似，在webpack打包出的代码中，每个模块也有一个对应的模块对象。在<code>__webpack_require__()</code>方法中，有这么一段代码：</p>

<pre><code class="language-javascript">function __webpack_require__(moduleId) {
    // …… other code
    
    var module = installedModules[moduleId] = {
        i: moduleId,
        l: false,
        exports: {},
        parents: null,
        children: []
    };
    
    // …… other code
}
</code></pre>

<p>类似于Node，在webpack中各个模块的也有对应的模块对象，其数据结构基本遵循CommonJS规范；其中<code>installedModules</code>则是模块缓存对象，类似于Node中的<code>require.cache</code>/<code>Module._cache</code>。</p>

<h3 id="toc_5">2.2. 模块的require：<code>__webpack_require__</code></h3>

<p><code>__webpack_require__</code>是webpack前端运行时模块化中非常重要的一个方法，相当于CommonJS规范中的<code>require</code>。</p>

<p>根据第一部分的流程图：在Node中，当我们<code>require</code>一个模块时，会先判断该模块是否在缓存之中，如果存在则直接返回该模块的<code>exports</code>属性；否则会加载并执行该模块。webpack中的实现也类似：</p>

<pre><code class="language-javascript">function __webpack_require__(moduleId) {
    // 1.首先会检查模块缓存
    if(installedModules[moduleId]) {
        return installedModules[moduleId].exports;
    }
    
    // 2. 缓存不存在时，创建并缓存一个新的模块对象，类似Node中的new Module操作
    var module = installedModules[moduleId] = {
        i: moduleId,
        l: false,
        exports: {},
        children: []
    };

    // 3. 执行模块，类似于Node中的：
    // result = compiledWrapper.call(this.exports, this.exports, require, this, filename, dirname);
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

    module.l = true;

    // 4. 返回该module的输出
    return module.exports;
}
</code></pre>

<p>如果你仔细对比webpack与Node，你会发现在<code>__webpack_require__</code>中有一个重要的区别：</p>

<p>在webpack中不存在像Node一样调用<code>._compile()</code>这种方法的过程。即不会像Node那样，对一个未载入缓存的模块，通过「读取模块路径 -&gt; 编译模块代码 -&gt; 执行模块」来载入模块。为什么呢？</p>

<p>这是因为，Node作为服务端语言，模块都是本地文件，加载时延低，可同步阻塞进行模块文件寻址、读取、编译和执行，这些过程在模块require的时候再“按需”执行即可；而webpack运行在客户端（浏览器），显然不能在需要时（即执行<code>__webpack_require__</code>时）再通过网络加载js文件，并同步地等待加载完成后再返回<code>__webpack_require__</code>。这种网络时延，显然不能满足“同步依赖”的要求。</p>

<p>那么webpack是如何解决这个问题的呢？</p>

<h3 id="toc_6">3.2. 如何解决前端的同步依赖</h3>

<p>我们还是回来看下Node：</p>

<p>Node（v10）中加载、编译与执行（js）模块的代码主要集中在<code>Module._extensions[&#39;.js&#39;]</code>和<code>Module.prototype._compile</code>中。首先会通过<code>fs.readFileSync</code>读取文件内容，然后通过<code>vm.runInThisContext</code>来编译和执行JavaScript代码。</p>

<blockquote>
<p>The vm module provides APIs for compiling and running code within V8 Virtual Machine contexts.</p>
</blockquote>

<p>但是，根据上面的分析，在前端runtime中肯定不能通过网络去同步获取JavaScript脚本文件；那么就需要我们换一个思路：有没有什么地方能够预先放置我们“之后”可能会需要的模块，让我们能够在require时不需要同步等待过长的时间（当然，这里的“之后”可能是几秒、几分钟后，也可能是这次事件循环task的下几行代码）。</p>

<p>内存就是一个不错的选择。我们可以把同步依赖的模块先“注册”到内存中（模块暂存），等到require时，再执行该模块、缓存模块对象、返回对应的<code>exports</code>。而webpack中，这个所谓的内存就是<code>modules</code>对象。</p>

<blockquote>
<p>注意这里指的模块暂存和模块缓存概念完全不同。暂存可以粗略类比为将编译好的模块代码先放到内存中，实际并没有引入该模块。基于这个目的，我们也可以把“模块暂存”理解为“模块注册”，因此后文中“模块暂存”与“模块注册”具有相等的概念。</p>
</blockquote>

<p>所以，过程大致是这样的：</p>

<p>当我们已经获取了模块内容后（但模块还未执行），我们就将其暂存在<code>modules</code>对象中，键就是webpack的moduleId；等到需要使用<code>__webpack_require__</code>引用模块时，发现缓存中没有，则从<code>modules</code>对象中取出暂存的模块并执行。</p>

<h3 id="toc_7">3.3. 如何”暂存“模块</h3>

<p>思路已经清晰了，那么我们就来看看，webpack是如何将模块“暂存”在<code>modules</code>对象上的。在实际上，webpack打包出来的代码可以简单分为两类：</p>

<ul>
<li>一类是webpack模块化的前端runtime，你可以简单类比为RequireJS这样的前端模块化类库所实现的功能。它会控制模块的加载、缓存，提供诸如<code>__webpack_require__</code>这样的require方法等。</li>
<li>另一类则是模块注册与运行的代码，包含了源码中的模块代码。为了进一步理解，我们先来看一下这部分的代码是怎样的。</li>
</ul>

<blockquote>
<p>为了便于学习与代码阅读，建议你可以在webpack（v4）配置中加入<code>optimization:{runtimeChunk: {name: &#39;runtime&#39;}}</code>，这样会让webpack将runtime与模块注册代码分开打包。</p>
</blockquote>

<pre><code class="language-JavaScript">// webpack module chunk
(window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []).push([[&quot;home-0&quot;],{

/***/ &quot;module-home-0&quot;:
/***/ (function(module, exports, __webpack_require__) {

const myalert = __webpack_require__(&quot;module-home-1&quot;);

myalert(&#39;test&#39;);

/***/ }),

/***/ &quot;module-home-1&quot;:
/***/ (function(module, exports) {

module.exports = function (a) {
    alert(&#39;hi:&#39; + a);
};

/***/ })

},[[&quot;module-home-0&quot;,&quot;home-1&quot;]]]);
</code></pre>

<p>上面这是一个不包含runtime的chunk，我们不妨将其称为module chunk（下面会沿用这个叫法）。简化一下这部分代码，大致结构如下：</p>

<pre><code class="language-JavaScript">// webpack module chunk
window[&quot;webpackJsonp&quot;].push([
    [&quot;home-0&quot;], // chunkIds
    {
        &quot;module-home-0&quot;: (function(module, exports, __webpack_require__){ /* some logic */ }),
        &quot;module-home-1&quot;: (function(module, exports, __webpack_require__){ /* some logic */ })
    },
    [[&quot;module-home-0&quot;,&quot;home-1&quot;]]
])
</code></pre>

<p>这里，<code>.push()</code>方法参数为一个数组，包含三个元素：</p>

<ul>
<li>第一个元素是一个数组，<code>[&quot;home-0&quot;]</code>表示该js文件所包含的所有chunk的id（可以粗略理解为，webpack中module组成chunk，chunk又组成file）；</li>
<li>第二个元素是一个对象，键是各个模块的id，值则是一个被function包装后的模块；</li>
<li>第三个元素也是一个数组，其又是由多个数组组成。具体作用我们先按下不表，最后再说。</li>
</ul>

<p>来看下参数数组的第二个元素 —— 包含模块代码的对象，你会发现这里方法签名是不是很像Node中的通过<code>Module.wrap()</code>进行的模块代码包装？没错，<a href="https://github.com/webpack/webpack/blob/master/lib/FunctionModuleTemplatePlugin.js#L16-L31">webpack源码</a>中也有类似，会像Node那样，将每个模块的代码用一个function包装起来。</p>

<p>而当webpack配置了runtime分离后，打包出的文件中会出现一个“纯净”的、不包含任何模块代码的runtime，其主要是一个自执行方法，其中暴露了一个全局变量<code>webpackJsonp</code>：</p>

<pre><code class="language-JavaScript">// webpack runtime chunk
var jsonpArray = window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || [];
var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
jsonpArray.push = webpackJsonpCallback;
</code></pre>

<blockquote>
<p><code>webpackJsonp</code>变量名可以通过<code>output.jsonpFunction</code>进行配置</p>
</blockquote>

<p>可以看到，<code>window[&quot;webpackJsonp&quot;]</code>上的<code>.push()</code>方法已经被修改为了<code>webpackJsonpCallback()</code>方法。该方法如下：</p>

<pre><code class="language-javascript">// webpack runtime chunk
function webpackJsonpCallback(data) {
    var chunkIds = data[0];
    var moreModules = data[1];
    var executeModules = data[2];

    var moduleId, chunkId, i = 0, resolves = [];
    // webpack会在installChunks中存储chunk的载入状态，据此判断chunk是否加载完毕
    for(;i &lt; chunkIds.length; i++) {
        chunkId = chunkIds[i];
        if(installedChunks[chunkId]) {
            resolves.push(installedChunks[chunkId][0]);
        }
        installedChunks[chunkId] = 0;
    }
    
    // 注意，这里会进行“注册”，将模块暂存入内存中
    // 将module chunk中第二个数组元素包含的 module 方法注册到 modules 对象里
    for(moduleId in moreModules) {
        if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
            modules[moduleId] = moreModules[moduleId];
        }
    }

    if(parentJsonpFunction) parentJsonpFunction(data);

    while(resolves.length) {
        resolves.shift()();
    }

    deferredModules.push.apply(deferredModules, executeModules || []);

    return checkDeferredModules();
};
</code></pre>

<p>注意以上方法的这几行，就是我们之前所说的「将模块“暂存”在modules对象上」</p>

<pre><code class="language-JavaScript">// webpackJsonpCallback
for(moduleId in moreModules) {
    if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
    modules[moduleId] = moreModules[moduleId];
    }
}
</code></pre>

<p>配合<code>__webpack_require__()</code>中下面这一行代码，就实现了在需要引入模块时，同步地将模块从暂存区取出来执行，避免使用网络请求导致过长的同步等待时间。</p>

<pre><code class="language-JavaScript">// __webpack_require__
modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
</code></pre>

<h3 id="toc_8">3.4. 模块的自动执行</h3>

<p>到目前为止，对于webpack的同步依赖实现已经介绍的差不多了，但还遗留一个小问题：webpack中的所有js源文件都是模块，但如果都是不会自动执行的模块，那我们只是在前端引入了一堆“死”代码，怎么让代码“活”起来呢？</p>

<p>很多时候，我们引入一个script标签加载脚本文件，至少希望其中一个模块的代码会自动执行，而不仅仅是注册在<code>modules</code>对象上。一般来说，这就是webpack中所谓的入口模块。</p>

<p>webpack是如何让这些入口模块自动执行的呢？不知道你是否还记得module chunk中那个按下不表的第三个参数：这个参数是一个数组，而数组里面每个元素又是一个数组</p>

<pre><code class="language-javascript">[[&quot;module-home-0&quot;,&quot;home-1&quot;], [&quot;module-home-2&quot;,&quot;home-3&quot;,&quot;home-5&quot;]]
</code></pre>

<p>对照上面这个例子，我们可以具体解释下参数的含义。第一个元素<code>[&quot;module-home-0&quot;,&quot;home-1&quot;]</code>表示，我希望自动执行moduleId为<code>module-home-0</code>的这个模块，但是该模块需要chunkId为<code>home-1</code>的chunk已经加载后才能执行；同理，<code>[&quot;module-home-2&quot;,&quot;home-3&quot;,&quot;home-5&quot;]</code>表示自动执行<code>module-home-2</code>模块，但是需要检查chunk<code>home-3</code>和<code>home-5</code>已经加载。</p>

<p>执行某些模块需要保证一些chunk已经加载是因为，该模块所依赖的其他模块可能并不在当前chunk中，而webpack在编译期会通过依赖分析自动将依赖模块的所属chunkId注入到此处。</p>

<p>这个模块“自动”执行的功能在runtime chunk的代码中主要是由<code>checkDeferredModules()</code>方法实现：</p>

<pre><code class="language-JavaScript">function checkDeferredModules() {
    var result;
    for(var i = 0; i &lt; deferredModules.length; i++) {
        var deferredModule = deferredModules[i];
        var fulfilled = true;
        // 第一个元素是模块id，后面是其所需的chunk
        for(var j = 1; j &lt; deferredModule.length; j++) {
            var depId = deferredModule[j];
            // 这里会首先判断模块所需chunk是否已经加载完毕
            if(installedChunks[depId] !== 0) fulfilled = false;
        }
        // 只有模块所需的chunk都加载完毕，该模块才会被执行（__webpack_require__）
        if(fulfilled) {
            deferredModules.splice(i--, 1);
            result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
        }
    }
    return result;
}
</code></pre>

<h2 id="toc_9">4. 异步依赖</h2>

<p>如果你只是想学习webpack前端runtime中同步依赖的设计与实现，那么到这里主要内容基本已经结束了。不过我们知道，webpack支持使用动态模块引入的语法（代码拆分），例如：<code>dynamic import</code>和早期的<code>require.ensure</code>，这种方式与使用CommonJS的<code>require</code>和ESM的<code>import</code>最重要的区别在于，该类方法会异步（或者说按需）加载依赖。</p>

<h3 id="toc_10">4.1. 代码转换</h3>

<p>就像在源码中使用<code>require</code>会在webpack打包时被替换为<code>__webpack_require__</code>一样，在源码中使用的异步依赖语法也会被webpack修改。以<code>dynamic import</code>为例，下面的代码</p>

<pre><code class="language-JavaScript">import(&#39;./test.js&#39;).then(mod =&gt; {
    console.log(mod);
});
</code></pre>

<p>在产出后会被转换为</p>

<pre><code class="language-JavaScript">__webpack_require__.e(/* import() */ &quot;home-1&quot;)
    .then(__webpack_require__.bind(null, &quot;module-home-3&quot;))
    .then(mod =&gt; {
        console.log(mod);
    });
</code></pre>

<p>上面代码是什么意思呢？我们知道，webpack打包后会将一些module合并为一个chunk，因此上面的<code>&quot;home-1&quot;</code>就表示：包含<code>./test.js</code>模块的chunk的chunkId为<code>&quot;home-1&quot;</code>。</p>

<p>webpack首先通过<code>__webpack_require__.e</code>加载指定chunk的script文件（module chunk），该方法返回一个promise，当script加载并执行完成后resolve该promise。webpack打包时会保证异步依赖的所有模块都已包含在该module chunk或当前上下文中。</p>

<p>既然module chunk已经执行，那么表明异步依赖已经就绪，于是在then方法中执行<code>__webpack_require__</code>引用<code>test.js</code>模块（webpack编译后moduleId为module-home-3）并返回。这样在第二个then方法中就可以正常使用该模块了。</p>

<h3 id="toc_11">4.2. <code>__webpack_require__.e</code></h3>

<p>异步依赖的核心方法就是<code>__webpack_require__.e</code>。下面来分析一下该方法：</p>

<pre><code class="language-JavaScript">__webpack_require__.e = function requireEnsure(chunkId) {
    var promises = [];
    var installedChunkData = installedChunks[chunkId];
    
    // 判断该chunk是否已经被加载，0表示已加载。installChunk中的状态：
    // undefined：chunk未进行加载,
    // null：chunk preloaded/prefetched
    // Promise：chunk正在加载中
    // 0：chunk加载完毕
    if(installedChunkData !== 0) {
        // chunk不为null和undefined，则为Promise，表示加载中，继续等待
        if(installedChunkData) {
            promises.push(installedChunkData[2]);
        } else {
            // 注意这里installChunk的数据格式
            // 从左到右三个元素分别为resolve、reject、promise
            var promise = new Promise(function(resolve, reject) {
                installedChunkData = installedChunks[chunkId] = [resolve, reject];
            });
            promises.push(installedChunkData[2] = promise);

            // 下面代码主要是根据chunkId加载对应的script脚本
            var head = document.getElementsByTagName(&#39;head&#39;)[0];
            var script = document.createElement(&#39;script&#39;);
            var onScriptComplete;

            script.charset = &#39;utf-8&#39;;
            script.timeout = 120;
            if (__webpack_require__.nc) {
                script.setAttribute(&quot;nonce&quot;, __webpack_require__.nc);
            }
            
            // jsonpScriptSrc方法会根据传入的chunkId返回对应的文件路径
            script.src = jsonpScriptSrc(chunkId);

            onScriptComplete = function (event) {
                script.onerror = script.onload = null;
                clearTimeout(timeout);
                var chunk = installedChunks[chunkId];
                if(chunk !== 0) {
                    if(chunk) {
                        var errorType = event &amp;&amp; (event.type === &#39;load&#39; ? &#39;missing&#39; : event.type);
                        var realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;
                        var error = new Error(&#39;Loading chunk &#39; + chunkId + &#39; failed.\n(&#39; + errorType + &#39;: &#39; + realSrc + &#39;)&#39;);
                        error.type = errorType;
                        error.request = realSrc;
                        chunk[1](error);
                    }
                    installedChunks[chunkId] = undefined;
                }
            };
            var timeout = setTimeout(function(){
                onScriptComplete({ type: &#39;timeout&#39;, target: script });
            }, 120000);
            script.onerror = script.onload = onScriptComplete;
            head.appendChild(script);
        }
    }
    return Promise.all(promises);
};
</code></pre>

<p>该方法首先会根据chunkId在installChunks中判断该chunk是否正在加载或已经被加载；如果没有则会创建一个promise，将其保存在installChunks中，并通过<code>jsonpScriptSrc()</code>方法获取文件路径，通过sciript标签加载，最后返回该promise。</p>

<p><code>jsonpScriptSrc()</code>则可以理解为一个包含chunk map的方法，例如这个例子中：</p>

<pre><code class="language-JavaScript">function jsonpScriptSrc(chunkId) {
    return __webpack_require__.p + &quot;&quot; + ({}[chunkId]||chunkId) + &quot;.&quot; + {&quot;home-1&quot;:&quot;0b49ae3b&quot;}[chunkId] + &quot;.js&quot;
}
</code></pre>

<p>其中包含一个map —— <code>{&quot;home-1&quot;:&quot;0b49ae3b&quot;}</code>，会根据home-1这个chunkId返回home-1.0b49ae3b.js这个文件名。</p>

<h3 id="toc_12">4.3. 更新chunk加载状态</h3>

<p>最后，你会发现，在onload中，并没有调用promise的resolve方法。那么是何时resolve的呢？</p>

<p>你还记得在介绍同步require时用于注册module的<code>webpackJsonpCallback()</code>方法么？我们之前说过，该方法参数数组中的第一个元素是一个chunkId的数组，代表了该脚本所包含的chunk。</p>

<blockquote>
<p>p.s. 当一个普通的脚本被浏览器下载完毕后，会先执行该脚本，然后触发onload事件。</p>
</blockquote>

<p>因此，在<code>webpackJsonpCallback()</code>方法中，有一段代码就是根据chunkIds的数组，检查并更新chunk的加载状态：</p>

<pre><code class="language-JavaScript">// webpackJsonpCallback()
var moduleId, chunkId, i = 0, resolves = [];
for(;i &lt; chunkIds.length; i++) {
    chunkId = chunkIds[i];
    if(installedChunks[chunkId]) {
        resolves.push(installedChunks[chunkId][0]);
    }
    installedChunks[chunkId] = 0;
}

// ……

while(resolves.length) {
    resolves.shift()();
}
</code></pre>

<p>上面的代码先根据模块注册时的chunkId，取出installedChunks对应的所有loading中的chunk，最后将这些chunk的promise进行resolve操作。</p>

<h2 id="toc_13">5. 写在最后</h2>

<p>至此，对于「webpack打包后是如何实现前端模块化」这个问题就差不多结束了。本文通过Node中的模块化为引子，介绍了webpack中的同步与异步模块加载的设计与实现。</p>

<p>为了方便大家对照文中内容查看webpack运行时源码，我把基础的webpack runtime chunk和module chunk放在了<a href="https://gitee.com/alienzhou/codes/o431yhewq8kimbtdnjpcl12">这里</a>，有兴趣的朋友可以对照着看。</p>

<p>最后还是欢迎对webpack感兴趣的朋友能够相互交流，关注我的系列文章。</p>

<h2 id="toc_14">参考资料</h2>

<ul>
<li><a href="https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js">NodeJS internal - cjs module loader</a></li>
<li><a href="https://github.com/webpack/webpack/blob/master/lib/MainTemplate.js">webpack MainTemplate</a></li>
<li><a href="https://github.com/webpack/webpack/blob/master/lib/FunctionModuleTemplatePlugin.js">webpack FunctionModuleTemplatePlugin</a></li>
<li><a href="https://github.com/webpack/webpack/blob/master/lib/RuntimeTemplate.js">webpack RuntimeTemplate</a></li>
<li><a href="https://gitee.com/alienzhou/codes/o431yhewq8kimbtdnjpcl12">webpack runtime chunk示例</a></li>
</ul>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="15354508213008.html"  title="Previous Post: 【PWA学习与实践】(10)使用Resource Hint提升页面加载性能与体验">&laquo; 【PWA学习与实践】(10)使用Resource Hint提升页面加载性能与体验</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="15333560595579.html" 
	        title="Next Post: 推荐阅读 2018.08">推荐阅读 2018.08 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '15353386669734.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
